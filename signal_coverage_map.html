<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å—é€šå¸‚ä¿¡å·è¦†ç›–åœ°å›¾</title>
    <style>
        /* é¡µé¢æ•´ä½“æ ·å¼ */
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f8f9fa;
        }

        /* æ ‡é¢˜åŒºåŸŸ */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            cursor: pointer;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
            padding: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
            pointer-events: auto;
            user-select: none;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .intensity-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .intensity-slider {
            width: 150px;
        }

        /* æ–‡ä»¶å¯¼å…¥é¢æ¿ */
        .import-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input {
            flex: 1;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .file-input:hover {
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* åœ°å›¾å®¹å™¨ */
        #map {
            width: 100%;
            height: 500px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* å›¾ä¾‹æ ·å¼ */
        .legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #dee2e6;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .red { background-color: #ff0000; }
        .orange { background-color: #ff8800; }
        .green { background-color: #00bb00; }
        .blue { background-color: #0088ff; }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    <!-- é¡µé¢æ ‡é¢˜ -->
    <div class="header">
        <h1>ğŸ—ºï¸ å—é€šå¸‚ä¿¡å·è¦†ç›–åœ°å›¾</h1>
        <p>å®æ—¶ç›‘æµ‹ç½‘ç»œä¿¡å·è´¨é‡åˆ†å¸ƒæƒ…å†µ</p>
    </div>

    <!-- Excelå¯¼å…¥é¢æ¿ -->
    <div class="import-panel">
        <h3>ğŸ“ Excelæ•°æ®å¯¼å…¥</h3>
        <div class="file-input-wrapper">
            <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls" />
            <button id="loadBtn" class="btn" onclick="loadExcelData()">åŠ è½½æ•°æ®</button>
            <button id="useDefaultBtn" class="btn" onclick="useDefaultData()">ä½¿ç”¨ç¤ºä¾‹æ•°æ®</button>
        </div>
        <div id="statusMessage"></div>
        <p><strong>Excelæ–‡ä»¶æ ¼å¼è¦æ±‚ï¼š</strong>åŒ…å«åˆ—ï¼šä½ç½®æè¿°ã€è¯¦ç»†åœ°å€ã€ç½‘ç»œç±»å‹ã€ä¿¡å·å¼ºåº¦ã€ä¸ŠæŠ¥æ—¶é—´ã€ä¸ŠæŠ¥äººã€å¤‡æ³¨</p>
    </div>

    <!-- ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel">
        <h3>ğŸ“Š ç›‘æµ‹ç‚¹æ¦‚å†µ</h3>
        <p id="dataInfo">è¯·å¯¼å…¥Excelæ–‡ä»¶æˆ–ä½¿ç”¨ç¤ºä¾‹æ•°æ®</p>
    </div>

    <!-- åœ°å›¾å®¹å™¨ -->
    <div id="map"></div>

    <!-- å›¾ä¾‹è¯´æ˜ -->
    <div class="legend">
        <h4>ğŸ“¶ ä¿¡å·å¼ºåº¦å›¾ä¾‹</h4>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 18px; height: 18px;"></div>
            <span>ä¸¥é‡ç›²åŒº (1-2åˆ†) - çº¢è‰²å¤§æ ‡è®°ï¼Œéœ€è¦ä¼˜å…ˆå¤„ç†</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 12px; height: 12px;"></div>
            <span>ä¿¡å·è¾ƒå·® (3-4åˆ†) - çº¢è‰²å°æ ‡è®°ï¼Œä¿¡å·ä¸ç¨³å®š</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 12px; height: 12px;"></div>
            <span>ä¿¡å·ä¸€èˆ¬ (5-6åˆ†) - è“è‰²å°æ ‡è®°ï¼Œä¿¡å·å¯ç”¨</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 18px; height: 18px;"></div>
            <span>ä¿¡å·è‰¯å¥½ (7-10åˆ†) - è“è‰²å¤§æ ‡è®°ï¼Œä¿¡å·ç¨³å®š</span>
        </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <h3>ğŸ“‹ æ§åˆ¶é¢æ¿</h3>
        <div class="control-group">
            <label>çƒ­åŠ›å›¾æ˜¾ç¤º</label>
            <label class="switch">
                <input type="checkbox" id="heatmapSwitch">
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>æ ‡è®°ç‚¹æ˜¾ç¤º</label>
            <label class="switch">
                <input type="checkbox" id="markersSwitch" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>ä¿¡å·å¼ºåº¦èŒƒå›´ (æ˜¾ç¤ºâ‰¤è¯¥å€¼çš„ç›‘æµ‹ç‚¹)</label>
            <div class="intensity-control">
                <input type="range" id="intensitySlider" min="1" max="10" value="10">
                <span id="intensityValue">10</span>
            </div>
        </div>
    </div>

    <!-- å¼•å…¥XLSXè§£æåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- é«˜å¾·åœ°å›¾API -->
    <script src="https://webapi.amap.com/maps?v=2.0&key=d9f68330ebc73e4856581f67deac33a5&plugin=AMap.HeatMap"></script>
    
    <script>
        // å…¨å±€å˜é‡
        let map = null;
        let markers = [];
        let currentData = [];
        let heatmapLayer = null;

        /**
         * ç”Ÿæˆéšæœºçš„å—é€šå¸‚ä¿¡å·ç›‘æµ‹æ•°æ®
         */
        function generateRandomData(count = 1000) {
            const data = [];
            
            // å—é€šå¸‚åŠå‘¨è¾¹æ›´å¤§åŒºåŸŸèŒƒå›´ (ç»çº¬åº¦è¾¹ç•Œ)
            const bounds = {
                minLng: 120.400,  // è¥¿è¾¹ç•Œ - æ‰©å±•åˆ°æµ·å®‰
                maxLng: 121.700,  // ä¸œè¾¹ç•Œ - æ‰©å±•åˆ°å¯ä¸œ
                minLat: 31.700,   // å—è¾¹ç•Œ - æ‰©å±•åˆ°æµ·é—¨å—éƒ¨
                maxLat: 32.600    // åŒ—è¾¹ç•Œ - æ‰©å±•åˆ°å¦‚ä¸œåŒ—éƒ¨
            };
            
            // å—é€šå¸‚å„åŒºå¿å’Œä¸»è¦åœ°æ ‡
            const locations = [
                "å´‡å·åŒº", "æ¸¯é—¸åŒº", "é€šå·åŒº", "æµ·é—¨åŒº", "å¯ä¸œå¸‚", "å¦‚ä¸œå¿", "æµ·å®‰å¸‚",
                "å—é€šå¸‚ä¸­å¿ƒ", "å—é€šç«è½¦ç«™", "å—é€šæ±½è½¦ç«™", "å—é€šå¤§å­¦", "å—é€šåŒ»é™¢",
                "æµ·é—¨å·¥ä¸šå›­", "å¯ä¸œæ¸¯å£", "å¦‚ä¸œé£ç”µåœº", "æµ·å®‰å¼€å‘åŒº", "é€šå·æ¹¾",
                "ç‹¼å±±æ™¯åŒº", "æ¿ æ²³å…¬å›­", "æ£®æ—é‡ç”ŸåŠ¨ç‰©å›­", "å—é€šåšç‰©è‹‘",
                "å•†åœº", "ä½å®…åŒº", "å­¦æ ¡", "åŒ»é™¢", "é“¶è¡Œ", "æ”¿åºœå¤§æ¥¼", "ç¤¾åŒºæœåŠ¡ä¸­å¿ƒ",
                "ä¹¡é•‡", "å†œæ‘", "é«˜é€Ÿå…¬è·¯", "å›½é“", "å¿é“", "ä¹¡é“", "æ¸”æ¸¯", "ç å¤´"
            ];
            
            const networks = ["5G", "4G", "3G"];
            const reporters = ["å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­", "é™ˆä¸ƒ", "åˆ˜å…«", "åŒ¿åç”¨æˆ·"];
            
            // é‡ç‚¹ç›‘æµ‹åŒºåŸŸä¸­å¿ƒç‚¹ï¼ˆæŸäº›åŒºåŸŸç›‘æµ‹ç‚¹ä¼šæ›´å¯†é›†ï¼‰
            const hotspots = [
                [120.863, 32.008],  // å—é€šå¸‚ä¸­å¿ƒ
                [121.177, 31.890],  // æµ·é—¨åŒº
                [121.657, 31.810],  // å¯ä¸œå¸‚
                [120.737, 32.481],  // å¦‚ä¸œå¿
                [120.462, 32.546],  // æµ·å®‰å¸‚
                [121.073, 32.267],  // é€šå·åŒº
                [120.885, 32.066]   // æ¸¯é—¸åŒº
            ];
            
            for (let i = 0; i < count; i++) {
                let lng, lat;
                
                // 30%çš„æ¦‚ç‡åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ç”Ÿæˆï¼Œ70%åœ¨å…¨åŸŸéšæœºç”Ÿæˆ
                if (Math.random() < 0.3 && hotspots.length > 0) {
                    // åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ç”Ÿæˆ
                    const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
                    const radius = 0.05; // é‡ç‚¹åŒºåŸŸåŠå¾„çº¦5å…¬é‡Œ
                    lng = hotspot[0] + (Math.random() - 0.5) * radius * 2;
                    lat = hotspot[1] + (Math.random() - 0.5) * radius * 2;
                } else {
                    // åœ¨å…¨åŸŸéšæœºç”Ÿæˆ
                    lng = bounds.minLng + Math.random() * (bounds.maxLng - bounds.minLng);
                    lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                }
                
                // æ ¹æ®ä½ç½®è°ƒæ•´ä¿¡å·å¼ºåº¦åˆ†å¸ƒ
                let signal;
                const rand = Math.random();
                
                // åˆ¤æ–­æ˜¯å¦åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ï¼ˆä¿¡å·ç›¸å¯¹è¾ƒå¥½ï¼‰
                const isNearHotspot = hotspots.some(hotspot => {
                    const distance = Math.sqrt(Math.pow(lng - hotspot[0], 2) + Math.pow(lat - hotspot[1], 2));
                    return distance < 0.08; // 8å…¬é‡Œå·¦å³
                });
                
                if (isNearHotspot) {
                    // åŸå¸‚åŒºåŸŸï¼šä¿¡å·ç›¸å¯¹è¾ƒå¥½
                    if (rand < 0.05) signal = Math.floor(Math.random() * 2) + 1;      // 5% ä¸¥é‡ç›²åŒº
                    else if (rand < 0.15) signal = Math.floor(Math.random() * 2) + 3; // 10% ä¿¡å·è¾ƒå·®  
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 3) + 5; // 35% ä¿¡å·ä¸€èˆ¬
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 50% ä¿¡å·è‰¯å¥½
                } else {
                    // éƒŠåŒº/å†œæ‘ï¼šä¿¡å·ç›¸å¯¹è¾ƒå·®
                    if (rand < 0.20) signal = Math.floor(Math.random() * 2) + 1;      // 20% ä¸¥é‡ç›²åŒº
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 2) + 3; // 30% ä¿¡å·è¾ƒå·®  
                    else if (rand < 0.85) signal = Math.floor(Math.random() * 3) + 5; // 35% ä¿¡å·ä¸€èˆ¬
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 15% ä¿¡å·è‰¯å¥½
                }
                
                // éšæœºç”Ÿæˆå…¶ä»–ä¿¡æ¯
                const location = locations[Math.floor(Math.random() * locations.length)];
                const network = networks[Math.floor(Math.random() * networks.length)];
                const reporter = reporters[Math.floor(Math.random() * reporters.length)];
                
                // éšæœºç”Ÿæˆæ—¶é—´ (æœ€è¿‘30å¤©)
                const date = new Date();
                date.setDate(date.getDate() - Math.floor(Math.random() * 30));
                const timeStr = date.toISOString().slice(0, 16).replace('T', ' ');
                
                data.push({
                    name: `${location}ç›‘æµ‹ç‚¹${i + 1}`,
                    position: [lng, lat],
                    signal: signal,
                    network: network,
                    reporter: reporter,
                    time: timeStr,
                    note: signal <= 2 ? "ä¿¡å·ç›²åŒºéœ€è¦é‡ç‚¹å…³æ³¨" : 
                          signal <= 4 ? "ä¿¡å·è¾ƒå¼±ï¼Œå»ºè®®ä¼˜åŒ–" : 
                          signal <= 7 ? "ä¿¡å·æ­£å¸¸" : "ä¿¡å·è‰¯å¥½"
                });
            }
            
            console.log(`ğŸ² ç”Ÿæˆäº†${count}ä¸ªéšæœºç›‘æµ‹ç‚¹æ•°æ®`);
            return data;
        }

        // é»˜è®¤ç¤ºä¾‹æ•°æ® (1000ä¸ªéšæœºç‚¹)
        const DEFAULT_DATA = generateRandomData(1000);

        // åœ°å›¾é…ç½®
        const MAP_CONFIG = {
            zoom: 10,  // é™ä½ç¼©æ”¾çº§åˆ«ä»¥æ˜¾ç¤ºæ›´å¤§åŒºåŸŸ
            center: [121.05, 32.15],  // è°ƒæ•´ä¸­å¿ƒç‚¹åˆ°å—é€šå¸‚å‡ ä½•ä¸­å¿ƒ
            viewMode: '2D'
        };

        /**
         * æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
         */
        function showMessage(message, type = 'success') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
            
            // 3ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        /**
         * æ ¹æ®ä¿¡å·å¼ºåº¦è·å–å›¾æ ‡é¢œè‰²å’Œå¤§å°
         * åªä½¿ç”¨ç¡®å®å¯ç”¨çš„é¢œè‰²ï¼šr(çº¢), b(è“)ï¼Œé€šè¿‡å¤§å°åŒºåˆ†å…¶ä»–çº§åˆ«
         */
        function getIconConfig(signal) {
            if (signal <= 2) {
                return { color: 'r', size: 30, type: 'ä¸¥é‡ç›²åŒº' };      // çº¢è‰²å¤§å›¾æ ‡ - ä¸¥é‡ç›²åŒº
            } else if (signal <= 4) {
                return { color: 'r', size: 20, type: 'ä¿¡å·è¾ƒå·®' };      // çº¢è‰²å°å›¾æ ‡ - ä¿¡å·è¾ƒå·®
            } else if (signal <= 6) {
                return { color: 'b', size: 20, type: 'ä¿¡å·ä¸€èˆ¬' };      // è“è‰²å°å›¾æ ‡ - ä¿¡å·ä¸€èˆ¬
            } else {
                return { color: 'b', size: 30, type: 'ä¿¡å·è‰¯å¥½' };      // è“è‰²å¤§å›¾æ ‡ - ä¿¡å·è‰¯å¥½
            }
        }

        /**
         * åˆ›å»ºè‡ªå®šä¹‰æ ‡è®°å›¾æ ‡
         */
        function createMarkerIcon(color, size = 25) {
            // ä½¿ç”¨ç¡®å®å¯ç”¨çš„v1.3ä¸»é¢˜å›¾æ ‡
            const iconHeight = Math.round(size * 1.36); // ä¿æŒå®½é«˜æ¯”
            return new AMap.Icon({
                size: new AMap.Size(size, iconHeight),
                image: `https://webapi.amap.com/theme/v1.3/markers/n/mark_${color}.png`,
                imageSize: new AMap.Size(size, iconHeight)
            });
        }

        /**
         * è·å–ä¿¡å·å¼ºåº¦æè¿°
         */
        function getSignalDescription(signal) {
            if (signal <= 2) return 'ä¸¥é‡ç›²åŒº ğŸ”´å¤§';
            if (signal <= 4) return 'ä¿¡å·è¾ƒå·® ğŸ”´å°';
            if (signal <= 6) return 'ä¿¡å·ä¸€èˆ¬ ğŸ”µå°';
            return 'ä¿¡å·è‰¯å¥½ ğŸ”µå¤§';
        }

        /**
         * åˆå§‹åŒ–åœ°å›¾
         */
        function initMap() {
            console.log('å¼€å§‹åˆå§‹åŒ–åœ°å›¾...');

            // æ£€æŸ¥é«˜å¾·åœ°å›¾APIæ˜¯å¦åŠ è½½æˆåŠŸ
            if (typeof AMap === 'undefined') {
                showMessage('âŒ é«˜å¾·åœ°å›¾APIåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼', 'error');
                return;
            }

            try {
                // åˆ›å»ºåœ°å›¾å®ä¾‹
                map = new AMap.Map('map', MAP_CONFIG);
                console.log('âœ… åœ°å›¾åˆ›å»ºæˆåŠŸ');

                // åœ°å›¾åŠ è½½å®Œæˆäº‹ä»¶
                map.on('complete', function() {
                    console.log('âœ… åœ°å›¾åŠ è½½å®Œæˆ');
                    showMessage('âœ… åœ°å›¾åˆå§‹åŒ–æˆåŠŸï¼Œè¯·å¯¼å…¥æ•°æ®æˆ–ä½¿ç”¨ç¤ºä¾‹æ•°æ®');
                    
                    // åˆå§‹åŒ–æ§åˆ¶é¢æ¿äº‹ä»¶
                    initControls();
                });

            } catch (error) {
                console.error('âŒ åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
                showMessage(`âŒ åœ°å›¾åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
            }
        }

        /**
         * æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°
         */
        function clearMarkers() {
            if (markers.length > 0) {
                map.remove(markers);
                markers = [];
            }
        }

        /**
         * æ·»åŠ ä¿¡å·ç›‘æµ‹ç‚¹æ ‡è®°
         */
        function addSignalMarkers(data) {
            clearMarkers();
            
            // å¦‚æœæ•°æ®é‡å¤ªå¤§ï¼Œè¿›è¡Œé‡‡æ ·æ˜¾ç¤ºä»¥æé«˜æ€§èƒ½
            let displayData = data;
            const MAX_MARKERS = 200; // æœ€å¤§æ˜¾ç¤º200ä¸ªæ ‡è®°ç‚¹
            
            if (data.length > MAX_MARKERS) {
                console.log(`æ•°æ®é‡è¿‡å¤§(${data.length}ä¸ªç‚¹)ï¼Œé‡‡æ ·æ˜¾ç¤º${MAX_MARKERS}ä¸ªä»£è¡¨æ€§æ ‡è®°ç‚¹`);
                
                // æŒ‰ä¿¡å·å¼ºåº¦åˆ†å±‚é‡‡æ ·ï¼Œç¡®ä¿å„ç§ä¿¡å·å¼ºåº¦éƒ½æœ‰ä»£è¡¨
                const severeBlinds = data.filter(p => p.signal <= 2);
                const poor = data.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = data.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = data.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                displayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
                
                showMessage(`ğŸ“ é‡‡æ ·æ˜¾ç¤º${displayData.length}ä¸ªä»£è¡¨æ€§ç›‘æµ‹ç‚¹ï¼Œå®Œæ•´æ•°æ®è¯·æŸ¥çœ‹çƒ­åŠ›å›¾`, 'info');
            }
            
            displayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                // åˆ›å»ºæ ‡è®°ç‚¹
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - ä¿¡å·å¼ºåº¦: ${point.signal}/10 (${iconConfig.type})`,
                    icon: icon
                });

                // æ·»åŠ åˆ°åœ°å›¾å’Œæ ‡è®°æ•°ç»„
                map.add(marker);
                markers.push(marker);
            });

            console.log(`âœ… å·²æ·»åŠ ${displayData.length}ä¸ªæ ‡è®°ç‚¹ï¼ˆæ€»æ•°æ®${data.length}ä¸ªï¼‰`);

            // æ›´æ–°ä¿¡æ¯é¢æ¿ï¼ˆä½¿ç”¨å®Œæ•´æ•°æ®ç»Ÿè®¡ï¼‰
            updateInfoPanel(data);
            
            // æ›´æ–°çƒ­åŠ›å›¾
            updateHeatmap();
        }

        /**
         * æ•°ç»„é‡‡æ ·å‡½æ•°
         */
        function sampleArray(array, sampleSize) {
            if (array.length <= sampleSize) return array;
            
            const step = array.length / sampleSize;
            const sampled = [];
            
            for (let i = 0; i < sampleSize; i++) {
                const index = Math.floor(i * step);
                if (index < array.length) {
                    sampled.push(array[index]);
                }
            }
            
            return sampled;
        }

        /**
         * æ›´æ–°ä¿¡æ¯é¢æ¿
         */
        function updateInfoPanel(data) {
            const totalPoints = data.length;
            const severeCount = data.filter(p => p.signal <= 2).length;
            const avgSignal = (data.reduce((sum, p) => sum + p.signal, 0) / totalPoints).toFixed(1);
            
            document.getElementById('dataInfo').innerHTML = `
                å½“å‰æ˜¾ç¤º <strong>${totalPoints}</strong> ä¸ªä¿¡å·ç›‘æµ‹ç‚¹ï¼Œ
                å…¶ä¸­ä¸¥é‡ç›²åŒº <strong>${severeCount}</strong> ä¸ªï¼Œ
                å¹³å‡ä¿¡å·å¼ºåº¦ <strong>${avgSignal}/10</strong>
            `;
        }

        /**
         * ä½¿ç”¨é»˜è®¤ç¤ºä¾‹æ•°æ®
         */
        function useDefaultData() {
            if (!map) {
                showMessage('âŒ è¯·å…ˆç­‰å¾…åœ°å›¾åŠ è½½å®Œæˆ', 'error');
                return;
            }

            currentData = DEFAULT_DATA;
            addSignalMarkers(currentData);
            showMessage(`âœ… å·²åŠ è½½ç¤ºä¾‹æ•°æ®ï¼Œæ˜¾ç¤º${currentData.length}ä¸ªç›‘æµ‹ç‚¹`);
        }

        /**
         * è§£æExcelæ–‡ä»¶
         */
        function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * å¤„ç†Excelæ•°æ®å¹¶è½¬æ¢ä¸ºåœ°å›¾æ ¼å¼
         */
        function processExcelData(excelData) {
            const processedData = [];
            
            excelData.forEach((row, index) => {
                // æ£€æŸ¥å¿…è¦å­—æ®µ
                if (!row['ä½ç½®æè¿°'] || !row['ä¿¡å·å¼ºåº¦']) {
                    console.warn(`è·³è¿‡ç¬¬${index + 1}è¡Œï¼šç¼ºå°‘å¿…è¦å­—æ®µ`);
                    return;
                }

                // è¿™é‡Œæš‚æ—¶ä½¿ç”¨ç¤ºä¾‹åæ ‡ï¼Œå®é™…åº”è¯¥è°ƒç”¨åœ°ç†ç¼–ç API
                // ä¸ºç®€åŒ–æ¼”ç¤ºï¼Œæˆ‘ä»¬ä½¿ç”¨å—é€šå‘¨è¾¹çš„éšæœºåæ ‡
                const basePosition = [120.863, 32.008];
                const randomOffset = () => (Math.random() - 0.5) * 0.1; // Â±0.05åº¦éšæœºåç§»
                
                const processed = {
                    name: row['ä½ç½®æè¿°'],
                    position: [
                        basePosition[0] + randomOffset(),
                        basePosition[1] + randomOffset()
                    ],
                    signal: parseInt(row['ä¿¡å·å¼ºåº¦']) || 5,
                    network: row['ç½‘ç»œç±»å‹'] || 'æœªçŸ¥',
                    reporter: row['ä¸ŠæŠ¥äºº'] || 'åŒ¿å',
                    time: row['ä¸ŠæŠ¥æ—¶é—´'] || 'æœªçŸ¥',
                    note: row['å¤‡æ³¨'] || 'æ— '
                };

                processedData.push(processed);
            });

            return processedData;
        }

        /**
         * åŠ è½½Excelæ•°æ®
         */
        async function loadExcelData() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('âŒ è¯·å…ˆé€‰æ‹©Excelæ–‡ä»¶', 'error');
                return;
            }

            if (!map) {
                showMessage('âŒ è¯·å…ˆç­‰å¾…åœ°å›¾åŠ è½½å®Œæˆ', 'error');
                return;
            }

            try {
                showMessage('ğŸ“Š æ­£åœ¨è§£æExcelæ–‡ä»¶...', 'info');
                
                // è§£æExcelæ–‡ä»¶
                const excelData = await parseExcelFile(file);
                console.log('Excelæ•°æ®:', excelData);

                // å¤„ç†æ•°æ®
                const processedData = processExcelData(excelData);
                
                if (processedData.length === 0) {
                    showMessage('âŒ æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ•°æ®è¡Œ', 'error');
                    return;
                }

                // æ›´æ–°å½“å‰æ•°æ®å¹¶æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š
                currentData = processedData;
                addSignalMarkers(currentData);
                
                showMessage(`âœ… æˆåŠŸå¯¼å…¥ ${processedData.length} æ¡æ•°æ®è®°å½•`);

            } catch (error) {
                console.error('Excelå¤„ç†é”™è¯¯:', error);
                showMessage(`âŒ Excelæ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            }
        }

        /**
         * åˆå§‹åŒ–æ§åˆ¶é¢æ¿
         */
        function initControls() {
            console.log('ğŸ›ï¸ åˆå§‹åŒ–æ§åˆ¶é¢æ¿...');
            
            // çƒ­åŠ›å›¾å¼€å…³
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch) {
                heatmapSwitch.addEventListener('change', function() {
                    console.log('çƒ­åŠ›å›¾å¼€å…³çŠ¶æ€:', this.checked);
                    if (this.checked) {
                        showHeatmap();
                    } else {
                        hideHeatmap();
                    }
                });
                console.log('âœ… çƒ­åŠ›å›¾å¼€å…³äº‹ä»¶ç»‘å®šæˆåŠŸ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°çƒ­åŠ›å›¾å¼€å…³å…ƒç´ ');
            }

            // æ ‡è®°ç‚¹å¼€å…³
            const markersSwitch = document.getElementById('markersSwitch');
            if (markersSwitch) {
                markersSwitch.addEventListener('change', function() {
                    console.log('æ ‡è®°ç‚¹å¼€å…³çŠ¶æ€:', this.checked);
                    if (this.checked) {
                        showMarkers();
                    } else {
                        hideMarkers();
                    }
                });
                console.log('âœ… æ ‡è®°ç‚¹å¼€å…³äº‹ä»¶ç»‘å®šæˆåŠŸ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°æ ‡è®°ç‚¹å¼€å…³å…ƒç´ ');
            }

            // å¼ºåº¦æ»‘å—
            const intensitySlider = document.getElementById('intensitySlider');
            const intensityValue = document.getElementById('intensityValue');
            
            if (intensitySlider && intensityValue) {
                // è®¾ç½®åˆå§‹å€¼
                intensityValue.textContent = intensitySlider.value;
                
                intensitySlider.addEventListener('input', function() {
                    intensityValue.textContent = this.value;
                    // åªæœ‰åœ¨æœ‰æ•°æ®æ—¶æ‰è¿›è¡Œç­›é€‰
                    if (currentData && currentData.length > 0) {
                        filterByIntensity(parseInt(this.value));
                    }
                });
                console.log('âœ… å¼ºåº¦æ»‘å—äº‹ä»¶ç»‘å®šæˆåŠŸï¼Œåˆå§‹å€¼:', intensitySlider.value);
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°å¼ºåº¦æ»‘å—å…ƒç´ ');
            }
        }

        /**
         * ç”ŸæˆåŸºäºç›‘æµ‹ç‚¹èšåˆçš„åˆ†åŒºçƒ­åŠ›å›¾æ•°æ®
         * å°†é™„è¿‘çš„ç›‘æµ‹ç‚¹èšåˆæˆä¸€ä¸ªä¸ªçƒ­åŠ›åŒºåŸŸ
         */
        function generateHeatmapData(data) {
            const heatData = [];
            
            console.log('ğŸ—ºï¸ ç”Ÿæˆåˆ†åŒºèšåˆçƒ­åŠ›å›¾...');
            
            // å…ˆå°†ç›‘æµ‹ç‚¹æŒ‰è·ç¦»èšåˆæˆç¾¤ç»„
            const clusters = clusterNearbyPoints(data, 0.15); // 15å…¬é‡Œå†…çš„ç‚¹èšåˆä¸ºä¸€ç»„ï¼Œå‡å°‘å­¤ç«‹ç‚¹
            
            console.log(`ğŸ“Š å°†${data.length}ä¸ªç›‘æµ‹ç‚¹èšåˆä¸º${clusters.length}ä¸ªçƒ­åŠ›åŒºåŸŸ`);
            
            // ä¸ºæ¯ä¸ªç¾¤ç»„ç”Ÿæˆä¸€ä¸ªçƒ­åŠ›åŒºåŸŸ
            clusters.forEach((cluster, index) => {
                const clusterCenter = calculateClusterCenter(cluster);
                const avgSignal = calculateAverageSignal(cluster);
                const clusterSize = cluster.length;
                
                console.log(`ğŸ”¥ åŒºåŸŸ${index + 1}: ${clusterSize}ä¸ªç›‘æµ‹ç‚¹, å¹³å‡ä¿¡å·${avgSignal.toFixed(1)}, ä¸­å¿ƒä½ç½®[${clusterCenter[0].toFixed(3)}, ${clusterCenter[1].toFixed(3)}]`);
                
                // ä¸ºè¯¥ç¾¤ç»„ç”Ÿæˆä¸€ä¸ªçƒ­åŠ›åŒºåŸŸ
                const clusterHeatPoints = generateClusterHeatArea(
                    clusterCenter[0], 
                    clusterCenter[1], 
                    avgSignal,
                    clusterSize
                );
                
                heatData.push(...clusterHeatPoints);
            });
            
            console.log(`ğŸ”¥ ç”Ÿæˆ${heatData.length}ä¸ªçƒ­åŠ›ç‚¹ï¼Œå½¢æˆ${clusters.length}ä¸ªç‹¬ç«‹çš„çƒ­åŠ›åŒºåŸŸ`);
            return heatData;
        }
        
        /**
         * å°†é™„è¿‘çš„ç›‘æµ‹ç‚¹èšåˆæˆç¾¤ç»„
         * ä½¿ç”¨ç®€å•çš„è·ç¦»èšåˆç®—æ³•
         */
        function clusterNearbyPoints(data, maxDistance) {
            const clusters = [];
            const used = new Set();
            
            data.forEach((point, index) => {
                if (used.has(index)) return;
                
                // åˆ›å»ºæ–°çš„ç¾¤ç»„
                const cluster = [point];
                used.add(index);
                
                // æŸ¥æ‰¾é™„è¿‘çš„ç‚¹åŠ å…¥ç¾¤ç»„
                data.forEach((otherPoint, otherIndex) => {
                    if (used.has(otherIndex)) return;
                    
                    const distance = calculateDistance(point.position, otherPoint.position);
                    if (distance <= maxDistance) {
                        cluster.push(otherPoint);
                        used.add(otherIndex);
                    }
                });
                
                clusters.push(cluster);
            });
            
            return clusters;
        }
        
        /**
         * è®¡ç®—ä¸¤ç‚¹é—´è·ç¦»
         */
        function calculateDistance(pos1, pos2) {
            return Math.sqrt(
                Math.pow(pos1[0] - pos2[0], 2) + 
                Math.pow(pos1[1] - pos2[1], 2)
            );
        }
        
        /**
         * è®¡ç®—ç¾¤ç»„ä¸­å¿ƒç‚¹
         */
        function calculateClusterCenter(cluster) {
            const sumLng = cluster.reduce((sum, point) => sum + point.position[0], 0);
            const sumLat = cluster.reduce((sum, point) => sum + point.position[1], 0);
            return [sumLng / cluster.length, sumLat / cluster.length];
        }
        
        /**
         * è®¡ç®—ç¾¤ç»„å¹³å‡ä¿¡å·å¼ºåº¦
         */
        function calculateAverageSignal(cluster) {
            const sumSignal = cluster.reduce((sum, point) => sum + point.signal, 0);
            return sumSignal / cluster.length;
        }
        
        /**
         * ä¸ºä¸€ä¸ªç›‘æµ‹ç‚¹ç¾¤ç»„ç”Ÿæˆçƒ­åŠ›åŒºåŸŸ
         */
        function generateClusterHeatArea(centerLng, centerLat, avgSignal, clusterSize) {
            const points = [];
            
            // æ ¹æ®ç¾¤ç»„å¤§å°å’Œä¿¡å·å¼ºåº¦ç¡®å®šçƒ­åŠ›åŒºåŸŸå‚æ•°
            const baseRadius = 0.03 + (clusterSize - 1) * 0.01; // ç¾¤ç»„è¶Šå¤§ï¼Œçƒ­åŠ›åŒºåŸŸè¶Šå¤§
            const heatRadius = baseRadius * (1 + (10 - avgSignal) * 0.2); // ä¿¡å·è¶Šå·®ï¼Œå½±å“èŒƒå›´è¶Šå¤§
            
            // ä¿¡å·å¼ºåº¦å’Œç¾¤ç»„å¤§å°è½¬æ¢ä¸ºçƒ­åŠ›å€¼
            const baseHeatValue = Math.max(40, (11 - avgSignal) * 25);
            const sizeMultiplier = Math.min(3, 1 + clusterSize * 0.1); // ç¾¤ç»„å¤§å°å½±å“çƒ­åŠ›å¼ºåº¦
            const centerHeatValue = baseHeatValue * sizeMultiplier;
            
            // ç”Ÿæˆä¸è§„åˆ™çš„çƒ­åŠ›åŒºåŸŸï¼ˆæ¨¡æ‹ŸçœŸå®çš„ä¿¡å·è¦†ç›–èŒƒå›´ï¼‰
            const layers = 6; // 6å±‚
            const basePointsPerLayer = 8; // åŸºç¡€æ¯å±‚8ä¸ªç‚¹
            
            // ä¸­å¿ƒç‚¹
            points.push({
                lng: centerLng,
                lat: centerLat,
                count: centerHeatValue
            });
            
            // ç”Ÿæˆä¸è§„åˆ™çš„çƒ­åŠ›åŒºåŸŸ
            for (let layer = 1; layer <= layers; layer++) {
                const layerRadius = (heatRadius * layer) / layers;
                const layerHeatValue = centerHeatValue * Math.pow(0.75, layer);
                const pointsInLayer = basePointsPerLayer + Math.floor(layer * 2); // å¤–å±‚ç‚¹æ›´å¤š
                
                for (let i = 0; i < pointsInLayer; i++) {
                    const angle = (i * 2 * Math.PI) / pointsInLayer;
                    
                    // æ·»åŠ æ›´å¤šéšæœºåç§»ï¼Œå½¢æˆä¸è§„åˆ™è¾¹ç•Œ
                    const radiusVariation = 0.3 + Math.random() * 0.4; // 0.3-0.7çš„å˜åŒ–
                    const actualRadius = layerRadius * radiusVariation;
                    
                    // è§’åº¦ä¹Ÿæ·»åŠ éšæœºåç§»
                    const angleOffset = (Math.random() - 0.5) * 0.5;
                    const actualAngle = angle + angleOffset;
                    
                    const lng = centerLng + actualRadius * Math.cos(actualAngle);
                    const lat = centerLat + actualRadius * Math.sin(actualAngle);
                    
                    points.push({
                        lng: lng,
                        lat: lat,
                        count: Math.max(15, layerHeatValue)
                    });
                }
            }
            
            return points;
        }

        /**
         * æ˜¾ç¤ºçƒ­åŠ›å›¾
         */
        function showHeatmap() {
            console.log('ğŸ”¥ å¼€å§‹æ˜¾ç¤ºçƒ­åŠ›å›¾...');
            
            if (!currentData || currentData.length === 0) {
                showMessage('âŒ è¯·å…ˆå¯¼å…¥æ•°æ®', 'error');
                document.getElementById('heatmapSwitch').checked = false;
                return;
            }

            if (heatmapLayer) {
                console.log('æ¸…é™¤ç°æœ‰çƒ­åŠ›å›¾...');
                hideHeatmap();
            }

            try {
                // æ£€æŸ¥AMap.HeatMapæ˜¯å¦å¯ç”¨
                if (typeof AMap === 'undefined' || !AMap.HeatMap) {
                    throw new Error('é«˜å¾·åœ°å›¾çƒ­åŠ›å›¾æ’ä»¶æœªåŠ è½½');
                }

                const heatData = generateHeatmapData(currentData);
                console.log('çƒ­åŠ›å›¾æ•°æ®:', heatData);
                
                heatmapLayer = new AMap.HeatMap(map, {
                    radius: 50, // ä¸­ç­‰åŠå¾„é€‚åˆèšåˆåŒºåŸŸ
                    opacity: [0.4, 0.8], // å¢åŠ é€æ˜åº¦è®©åŒºåŸŸæ›´æ˜æ˜¾
                    gradient: {
                        '0.0': '#0066ff',  // ä¿¡å·å¥½ - æ·±è“è‰²
                        '0.2': '#0088ff',  // ä¿¡å·è¾ƒå¥½ - è“è‰²
                        '0.4': '#00ff88',  // ä¿¡å·ä¸€èˆ¬ - ç»¿è‰²
                        '0.6': '#ffff00',  // ä¿¡å·è¾ƒå·® - é»„è‰²  
                        '0.8': '#ff8800',  // ä¿¡å·å·® - æ©™è‰²
                        '1.0': '#ff0000'   // ä¿¡å·ç›²åŒº - çº¢è‰²
                    },
                    blur: 0.7, // é€‚åº¦æ¨¡ç³Šä¿æŒåŒºåŸŸè¾¹ç•Œæ¸…æ™°
                    max: 400   // è®¾ç½®æœ€å¤§çƒ­åŠ›å€¼é€‚åº”èšåˆæ•°æ®
                });
                
                // è®¡ç®—æ•°æ®ä¸­çš„æœ€å¤§æƒé‡å€¼
                const maxWeight = Math.max(...heatData.map(item => item.count));
                console.log('çƒ­åŠ›å›¾æœ€å¤§æƒé‡å€¼:', maxWeight);
                
                heatmapLayer.setDataSet({
                    data: heatData,
                    max: maxWeight || 100 // ä½¿ç”¨å®é™…æœ€å¤§å€¼æˆ–é»˜è®¤100
                });

                console.log('âœ… çƒ­åŠ›å›¾æ˜¾ç¤ºæˆåŠŸ');
                showMessage('ğŸ”¥ çƒ­åŠ›å›¾å·²å¼€å¯ï¼Œçº¢è‰²åŒºåŸŸä¸ºä¿¡å·ç›²åŒº');
                
            } catch (error) {
                console.error('âŒ çƒ­åŠ›å›¾æ˜¾ç¤ºå¤±è´¥:', error);
                showMessage(`âŒ çƒ­åŠ›å›¾æ˜¾ç¤ºå¤±è´¥: ${error.message}`, 'error');
                document.getElementById('heatmapSwitch').checked = false;
            }
        }

        /**
         * éšè—çƒ­åŠ›å›¾
         */
        function hideHeatmap() {
            console.log('ğŸŒ«ï¸ éšè—çƒ­åŠ›å›¾...');
            if (heatmapLayer) {
                try {
                    heatmapLayer.hide();
                    heatmapLayer.setMap(null);
                    heatmapLayer = null;
                    console.log('âœ… çƒ­åŠ›å›¾å·²éšè—');
                    showMessage('âœ… çƒ­åŠ›å›¾å·²å…³é—­');
                } catch (error) {
                    console.error('éšè—çƒ­åŠ›å›¾å¤±è´¥:', error);
                }
            } else {
                console.log('çƒ­åŠ›å›¾ä¸å­˜åœ¨ï¼Œæ— éœ€éšè—');
            }
        }

        /**
         * æ˜¾ç¤ºæ ‡è®°ç‚¹
         */
        function showMarkers() {
            console.log('ğŸ“ æ˜¾ç¤ºæ ‡è®°ç‚¹...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.show();
                });
                console.log('âœ… æ ‡è®°ç‚¹å·²æ˜¾ç¤º');
                showMessage('ğŸ“ æ ‡è®°ç‚¹å·²æ˜¾ç¤º');
            }
        }

        /**
         * éšè—æ ‡è®°ç‚¹
         */
        function hideMarkers() {
            console.log('ğŸ“ éšè—æ ‡è®°ç‚¹...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.hide();
                });
                console.log('âœ… æ ‡è®°ç‚¹å·²éšè—');
                showMessage('ğŸ“ æ ‡è®°ç‚¹å·²éšè—');
            }
        }

        /**
         * æ ¹æ®ä¿¡å·å¼ºåº¦ç­›é€‰æ˜¾ç¤º
         */
        function filterByIntensity(maxIntensity) {
            if (!currentData || currentData.length === 0) return;
            
            // ç­›é€‰æ•°æ®
            const filteredData = currentData.filter(point => point.signal <= maxIntensity);
            
            // æ¸…é™¤ç°æœ‰æ ‡è®°
            clearMarkers();
            
            // é‡æ–°æ·»åŠ ç¬¦åˆæ¡ä»¶çš„æ ‡è®° (ä½¿ç”¨ç­›é€‰åçš„æ•°æ®ï¼Œä½†ä¸æ”¹å˜currentData)
            const displayData = filteredData;
            
            // é‡‡æ ·æ˜¾ç¤ºé€»è¾‘ (ä»addSignalMarkerså‡½æ•°å¤åˆ¶è¿‡æ¥)
            let finalDisplayData = displayData;
            const MAX_MARKERS = 200;
            
            if (displayData.length > MAX_MARKERS) {
                const severeBlinds = displayData.filter(p => p.signal <= 2);
                const poor = displayData.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = displayData.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = displayData.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                finalDisplayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
            }
            
            // æ·»åŠ æ ‡è®°
            finalDisplayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - ä¿¡å·å¼ºåº¦: ${point.signal}/10 (${getSignalDescription(point.signal)})`,
                    icon: icon
                });

                map.add(marker);
                markers.push(marker);
            });
            
            // æ›´æ–°ä¿¡æ¯é¢æ¿
            updateInfoPanel(filteredData);
            
            // æ›´æ–°çƒ­åŠ›å›¾ (å¦‚æœå¼€å¯äº†çƒ­åŠ›å›¾)
            if (heatmapLayer) {
                hideHeatmap();
                setTimeout(() => {
                    const originalData = currentData; // ä¿å­˜åŸå§‹æ•°æ®
                    currentData = filteredData; // ä¸´æ—¶è®¾ç½®ä¸ºç­›é€‰æ•°æ®
                    showHeatmap();
                    currentData = originalData; // æ¢å¤åŸå§‹æ•°æ®
                }, 100);
            }
            
            showMessage(`ğŸ” æ˜¾ç¤ºä¿¡å·å¼ºåº¦ â‰¤ ${maxIntensity} çš„ç›‘æµ‹ç‚¹ (${filteredData.length} ä¸ª)`);
        }

        /**
         * æ›´æ–°çƒ­åŠ›å›¾ (æ•°æ®å˜åŒ–æ—¶è°ƒç”¨)
         */
        function updateHeatmap() {
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch && heatmapSwitch.checked) {
                hideHeatmap();
                setTimeout(showHeatmap, 100);
            }
        }

        /**
         * æµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½
         */
        function testHeatmap() {
            console.log('ğŸ§ª æµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½...');
            console.log('AMapå¯¹è±¡:', typeof AMap);
            console.log('AMap.HeatMapå¯¹è±¡:', typeof AMap.HeatMap);
            console.log('åœ°å›¾å¯¹è±¡:', map);
            console.log('å½“å‰æ•°æ®:', currentData);
            console.log('çƒ­åŠ›å›¾å±‚:', heatmapLayer);
            
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            console.log('çƒ­åŠ›å›¾å¼€å…³å…ƒç´ :', heatmapSwitch);
            console.log('å¼€å…³çŠ¶æ€:', heatmapSwitch ? heatmapSwitch.checked : 'å…ƒç´ ä¸å­˜åœ¨');
            
            // æ‰‹åŠ¨æµ‹è¯•çƒ­åŠ›å›¾å¼€å…³
            if (heatmapSwitch) {
                console.log('ç‚¹å‡»å¼€å…³è¿›è¡Œæµ‹è¯•...');
                heatmapSwitch.click();
            }
        }

        /**
         * æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾æ˜¾ç¤ºï¼ˆè°ƒè¯•ç”¨ï¼‰
         */
        function manualShowHeatmap() {
            console.log('ğŸ”¥ æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾æ˜¾ç¤º...');
            if (currentData.length === 0) {
                useDefaultData();
                setTimeout(() => {
                    showHeatmap();
                }, 1000);
            } else {
                showHeatmap();
            }
        }

        /**
         * æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾éšè—ï¼ˆè°ƒè¯•ç”¨ï¼‰
         */
        function manualHideHeatmap() {
            console.log('ğŸŒ«ï¸ æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾éšè—...');
            hideHeatmap();
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åœ°å›¾
        window.onload = function() {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            initMap();
            
            // 5ç§’åæµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½ï¼ˆç»™åœ°å›¾æ—¶é—´åŠ è½½ï¼‰
            setTimeout(testHeatmap, 5000);
        };
    </script>
</body>
</html> 