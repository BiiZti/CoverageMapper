<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>南通市信号覆盖地图</title>
    <style>
        /* 页面整体样式 */
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f8f9fa;
        }

        /* 标题区域 */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
        }

        /* 控制面板样式 */
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            cursor: pointer;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
            padding: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
            pointer-events: auto;
            user-select: none;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .intensity-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .intensity-slider {
            width: 150px;
        }

        /* 文件导入面板 */
        .import-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input {
            flex: 1;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .file-input:hover {
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* 信息面板 */
        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* 地图容器 */
        #map {
            width: 100%;
            height: 500px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* 图例样式 */
        .legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #dee2e6;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .red { background-color: #ff0000; }
        .orange { background-color: #ff8800; }
        .green { background-color: #00bb00; }
        .blue { background-color: #0088ff; }

        /* 加载状态 */
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .info {
            background: #cce7ff;
            color: #0066cc;
            border: 1px solid #99ccff;
        }

        .analysis-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 15px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
        }

        .analysis-panel h4 {
            margin-top: 0;
            color: #fff;
            font-size: 18px;
        }

        .analysis-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
            backdrop-filter: blur(10px);
        }

        .analysis-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }

        .metric-label {
            font-weight: 500;
        }

        .metric-value {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- 页面标题 -->
    <div class="header">
        <h1>🗺️ 南通市信号覆盖地图</h1>
        <p>实时监测网络信号质量分布情况</p>
    </div>

    <!-- Excel导入面板 -->
    <div class="import-panel">
        <h3>📁 Excel数据导入</h3>
        <div class="file-input-wrapper">
            <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls" />
            <button id="loadBtn" class="btn" onclick="loadExcelData()">加载数据</button>
            <button id="useDefaultBtn" class="btn" onclick="useDefaultData()">使用示例数据</button>
        </div>
        <div id="statusMessage"></div>
        <p><strong>Excel文件格式要求：</strong>包含列：位置描述、详细地址、网络类型、信号强度、上报时间、上报人、备注</p>
    </div>

    <!-- 信息面板 -->
    <div class="info-panel">
        <h3>📊 监测点概况</h3>
        <p id="dataInfo">请导入Excel文件或使用示例数据</p>
    </div>

    <!-- 地图容器 -->
    <div id="map"></div>

    <!-- 图例说明 -->
    <div class="legend">
        <h4>📶 信号强度图例</h4>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 18px; height: 18px;"></div>
            <span>严重盲区 (1-2分) - 红色大标记，需要优先处理</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 12px; height: 12px;"></div>
            <span>信号较差 (3-4分) - 红色小标记，信号不稳定</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 12px; height: 12px;"></div>
            <span>信号一般 (5-6分) - 蓝色小标记，信号可用</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 18px; height: 18px;"></div>
            <span>信号良好 (7-10分) - 蓝色大标记，信号稳定</span>
        </div>
    </div>

    <!-- 控制面板 -->
    <div class="control-panel">
        <h3>📋 控制面板</h3>
        <div class="control-group">
            <label>热力图显示</label>
            <label class="switch">
                <input type="checkbox" id="heatmapSwitch">
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>标记点显示</label>
            <label class="switch">
                <input type="checkbox" id="markersSwitch" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>信号强度范围 (显示≤该值的监测点)</label>
            <div class="intensity-control">
                <input type="range" id="intensitySlider" min="1" max="10" value="10">
                <span id="intensityValue">10</span>
            </div>
        </div>
        <div class="control-group">
            <button id="smartAnalysisBtn" class="btn" onclick="runSmartAnalysis()">🧠 智能分析</button>
            <button id="predictCoverageBtn" class="btn" onclick="predictSignalCoverage()">🔮 信号预测</button>
        </div>
        <div id="analysisResults" class="analysis-panel" style="display: none;">
            <h4>📈 智能分析结果</h4>
            <div id="analysisContent"></div>
        </div>
    </div>

    <!-- 引入XLSX解析库 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- 高德地图API -->
    <script src="https://webapi.amap.com/maps?v=2.0&key=d9f68330ebc73e4856581f67deac33a5&plugin=AMap.HeatMap"></script>
    
    <script>
        /**
         * ===========================================
         * 信号覆盖地图可视化系统
         * Signal Coverage Mapper Visualization System
         * 
         * @description 基于高德地图的网络信号质量可视化工具
         * @author Signal Coverage Mapper Team
         * @version 1.0.0
         * @license MIT
         * ===========================================
         */

        // =====================================
        // 全局变量定义
        // =====================================
        let map = null;                    // 高德地图实例
        let markers = [];                  // 标记点数组
        let currentData = [];              // 当前显示的数据
        let heatmapLayer = null;           // 热力图图层

        /**
         * 生成随机的南通市信号监测数据
         */
        function generateRandomData(count = 1000) {
            const data = [];
            
            // 南通市及周边更大区域范围 (经纬度边界)
            const bounds = {
                minLng: 120.400,  // 西边界 - 扩展到海安
                maxLng: 121.700,  // 东边界 - 扩展到启东
                minLat: 31.700,   // 南边界 - 扩展到海门南部
                maxLat: 32.600    // 北边界 - 扩展到如东北部
            };
            
            // 南通市各区县和主要地标
            const locations = [
                "崇川区", "港闸区", "通州区", "海门区", "启东市", "如东县", "海安市",
                "南通市中心", "南通火车站", "南通汽车站", "南通大学", "南通医院",
                "海门工业园", "启东港口", "如东风电场", "海安开发区", "通州湾",
                "狼山景区", "濠河公园", "森林野生动物园", "南通博物苑",
                "商场", "住宅区", "学校", "医院", "银行", "政府大楼", "社区服务中心",
                "乡镇", "农村", "高速公路", "国道", "县道", "乡道", "渔港", "码头"
            ];
            
            const networks = ["5G", "4G", "3G"];
            const reporters = ["张三", "李四", "王五", "赵六", "陈七", "刘八", "匿名用户"];
            
            // 重点监测区域中心点（某些区域监测点会更密集）
            const hotspots = [
                [120.863, 32.008],  // 南通市中心
                [121.177, 31.890],  // 海门区
                [121.657, 31.810],  // 启东市
                [120.737, 32.481],  // 如东县
                [120.462, 32.546],  // 海安市
                [121.073, 32.267],  // 通州区
                [120.885, 32.066]   // 港闸区
            ];
            
            for (let i = 0; i < count; i++) {
                let lng, lat;
                
                // 30%的概率在重点区域附近生成，70%在全域随机生成
                if (Math.random() < 0.3 && hotspots.length > 0) {
                    // 在重点区域附近生成
                    const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
                    const radius = 0.05; // 重点区域半径约5公里
                    lng = hotspot[0] + (Math.random() - 0.5) * radius * 2;
                    lat = hotspot[1] + (Math.random() - 0.5) * radius * 2;
                } else {
                    // 在全域随机生成
                    lng = bounds.minLng + Math.random() * (bounds.maxLng - bounds.minLng);
                    lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                }
                
                // 根据位置调整信号强度分布
                let signal;
                const rand = Math.random();
                
                // 判断是否在重点区域附近（信号相对较好）
                const isNearHotspot = hotspots.some(hotspot => {
                    const distance = Math.sqrt(Math.pow(lng - hotspot[0], 2) + Math.pow(lat - hotspot[1], 2));
                    return distance < 0.08; // 8公里左右
                });
                
                if (isNearHotspot) {
                    // 城市区域：信号相对较好
                    if (rand < 0.05) signal = Math.floor(Math.random() * 2) + 1;      // 5% 严重盲区
                    else if (rand < 0.15) signal = Math.floor(Math.random() * 2) + 3; // 10% 信号较差  
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 3) + 5; // 35% 信号一般
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 50% 信号良好
                } else {
                    // 郊区/农村：信号相对较差
                    if (rand < 0.20) signal = Math.floor(Math.random() * 2) + 1;      // 20% 严重盲区
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 2) + 3; // 30% 信号较差  
                    else if (rand < 0.85) signal = Math.floor(Math.random() * 3) + 5; // 35% 信号一般
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 15% 信号良好
                }
                
                // 随机生成其他信息
                const location = locations[Math.floor(Math.random() * locations.length)];
                const network = networks[Math.floor(Math.random() * networks.length)];
                const reporter = reporters[Math.floor(Math.random() * reporters.length)];
                
                // 随机生成时间 (最近30天)
                const date = new Date();
                date.setDate(date.getDate() - Math.floor(Math.random() * 30));
                const timeStr = date.toISOString().slice(0, 16).replace('T', ' ');
                
                data.push({
                    name: `${location}监测点${i + 1}`,
                    position: [lng, lat],
                    signal: signal,
                    network: network,
                    reporter: reporter,
                    time: timeStr,
                    note: signal <= 2 ? "信号盲区需要重点关注" : 
                          signal <= 4 ? "信号较弱，建议优化" : 
                          signal <= 7 ? "信号正常" : "信号良好"
                });
            }
            
            console.log(`🎲 生成了${count}个随机监测点数据`);
            return data;
        }

        // =====================================
        // 配置常量定义
        // =====================================
        
        // 地图配置
        const MAP_CONFIG = {
            zoom: 10,                    // 缩放级别
            center: [121.05, 32.15],     // 南通市几何中心
            viewMode: '2D',              // 2D视图模式
            maxZoom: 18,                 // 最大缩放级别
            minZoom: 3                   // 最小缩放级别
        };

        // 标记点配置
        const MARKER_CONFIG = {
            maxDisplay: 200,             // 最大显示标记点数量
            severeSizeMultiplier: 1.5,   // 严重盲区大小倍数
            iconBaseSize: 20             // 基础图标大小
        };

        // 信号强度阈值配置
        const SIGNAL_THRESHOLDS = {
            severe: 2,                   // 严重盲区：≤2分
            poor: 4,                     // 信号较差：3-4分
            normal: 6,                   // 信号一般：5-6分
            good: 10                     // 信号良好：7-10分
        };

        // 热力图配置
        const HEATMAP_CONFIG = {
            radius: 60,                  // 热力图半径
            opacity: [0, 0.8],           // 透明度范围
            clustering: {
                distance: 15000,         // 聚类距离（米）
                minPoints: 3             // 最小聚类点数
            }
        };

        // 默认示例数据 (1000个随机点)
        const DEFAULT_DATA = generateRandomData(1000);

        // =====================================
        // 工具函数模块
        // =====================================

        /**
         * 显示状态消息
         * @description 在页面上显示操作状态信息，支持成功、错误、信息等类型
         * @param {string} message - 要显示的消息内容
         * @param {string} type - 消息类型：success/error/info/warning
         * @returns {void}
         */
        function showMessage(message, type = 'success') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
            
            // 3秒后自动清除消息
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        /**
         * 根据信号强度获取图标配置
         * @description 根据信号强度值返回对应的颜色、大小和类型描述
         * @param {number} signal - 信号强度值 (1-10)
         * @returns {Object} 包含color、size、type的配置对象
         * @note 只使用高德地图支持的颜色：r(红), b(蓝)，通过大小区分级别
         */
        function getIconConfig(signal) {
            const baseSize = MARKER_CONFIG.iconBaseSize;
            const largeSize = Math.round(baseSize * MARKER_CONFIG.severeSizeMultiplier);
            
            if (signal <= SIGNAL_THRESHOLDS.severe) {
                return { color: 'r', size: largeSize, type: '严重盲区' };
            } else if (signal <= SIGNAL_THRESHOLDS.poor) {
                return { color: 'r', size: baseSize, type: '信号较差' };
            } else if (signal <= SIGNAL_THRESHOLDS.normal) {
                return { color: 'b', size: baseSize, type: '信号一般' };
            } else {
                return { color: 'b', size: largeSize, type: '信号良好' };
            }
        }

        /**
         * 创建自定义标记图标
         */
        function createMarkerIcon(color, size = 25) {
            // 使用确实可用的v1.3主题图标
            const iconHeight = Math.round(size * 1.36); // 保持宽高比
            return new AMap.Icon({
                size: new AMap.Size(size, iconHeight),
                image: `https://webapi.amap.com/theme/v1.3/markers/n/mark_${color}.png`,
                imageSize: new AMap.Size(size, iconHeight)
            });
        }

        /**
         * 获取信号强度描述
         */
        function getSignalDescription(signal) {
            if (signal <= 2) return '严重盲区 🔴大';
            if (signal <= 4) return '信号较差 🔴小';
            if (signal <= 6) return '信号一般 🔵小';
            return '信号良好 🔵大';
        }

        // =====================================
        // 地图操作模块
        // =====================================

        /**
         * 初始化地图
         * @description 创建高德地图实例，设置基本配置和事件监听
         * @returns {void}
         */
        function initMap() {
            console.log('开始初始化地图...');

            // 检查高德地图API是否加载成功
            if (typeof AMap === 'undefined') {
                showMessage('❌ 高德地图API加载失败，请检查网络连接！', 'error');
                return;
            }

            try {
                // 创建地图实例
                map = new AMap.Map('map', MAP_CONFIG);
                console.log('✅ 地图创建成功');

                // 地图加载完成事件
                map.on('complete', function() {
                    console.log('✅ 地图加载完成');
                    showMessage('✅ 地图初始化成功，请导入数据或使用示例数据');
                    
                    // 初始化控制面板事件
                    initControls();
                });

            } catch (error) {
                console.error('❌ 地图初始化失败:', error);
                showMessage(`❌ 地图初始化失败: ${error.message}`, 'error');
            }
        }

        /**
         * 清除地图上的所有标记
         */
        function clearMarkers() {
            if (markers.length > 0) {
                map.remove(markers);
                markers = [];
            }
        }

        /**
         * 添加信号监测点标记
         */
        function addSignalMarkers(data) {
            clearMarkers();
            
            // 如果数据量太大，进行采样显示以提高性能
            let displayData = data;
            const maxMarkers = MARKER_CONFIG.maxDisplay;
            
            if (data.length > maxMarkers) {
                console.log(`数据量过大(${data.length}个点)，采样显示${maxMarkers}个代表性标记点`);
                
                // 按信号强度分层采样，确保各种信号强度都有代表
                const severeBlinds = data.filter(p => p.signal <= 2);
                const poor = data.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = data.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = data.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                displayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
                
                showMessage(`📍 采样显示${displayData.length}个代表性监测点，完整数据请查看热力图`, 'info');
            }
            
            displayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                // 创建标记点
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - 信号强度: ${point.signal}/10 (${iconConfig.type})`,
                    icon: icon
                });

                // 添加到地图和标记数组
                map.add(marker);
                markers.push(marker);
            });

            console.log(`✅ 已添加${displayData.length}个标记点（总数据${data.length}个）`);

            // 更新信息面板（使用完整数据统计）
            updateInfoPanel(data);
            
            // 更新热力图
            updateHeatmap();
        }

        /**
         * 数组采样函数
         */
        function sampleArray(array, sampleSize) {
            if (array.length <= sampleSize) return array;
            
            const step = array.length / sampleSize;
            const sampled = [];
            
            for (let i = 0; i < sampleSize; i++) {
                const index = Math.floor(i * step);
                if (index < array.length) {
                    sampled.push(array[index]);
                }
            }
            
            return sampled;
        }

        /**
         * 更新信息面板
         */
        function updateInfoPanel(data) {
            const totalPoints = data.length;
            const severeCount = data.filter(p => p.signal <= 2).length;
            const avgSignal = (data.reduce((sum, p) => sum + p.signal, 0) / totalPoints).toFixed(1);
            
            document.getElementById('dataInfo').innerHTML = `
                当前显示 <strong>${totalPoints}</strong> 个信号监测点，
                其中严重盲区 <strong>${severeCount}</strong> 个，
                平均信号强度 <strong>${avgSignal}/10</strong>
            `;
        }

        /**
         * 使用默认示例数据
         */
        function useDefaultData() {
            if (!map) {
                showMessage('❌ 请先等待地图加载完成', 'error');
                return;
            }

            currentData = DEFAULT_DATA;
            addSignalMarkers(currentData);
            showMessage(`✅ 已加载示例数据，显示${currentData.length}个监测点`);
        }

        /**
         * 解析Excel文件
         */
        function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('文件读取失败'));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * 处理Excel数据并转换为地图格式
         */
        function processExcelData(excelData) {
            const processedData = [];
            
            excelData.forEach((row, index) => {
                // 检查必要字段
                if (!row['位置描述'] || !row['信号强度']) {
                    console.warn(`跳过第${index + 1}行：缺少必要字段`);
                    return;
                }

                // 这里暂时使用示例坐标，实际应该调用地理编码API
                // 为简化演示，我们使用南通周边的随机坐标
                const basePosition = [120.863, 32.008];
                const randomOffset = () => (Math.random() - 0.5) * 0.1; // ±0.05度随机偏移
                
                const processed = {
                    name: row['位置描述'],
                    position: [
                        basePosition[0] + randomOffset(),
                        basePosition[1] + randomOffset()
                    ],
                    signal: parseInt(row['信号强度']) || 5,
                    network: row['网络类型'] || '未知',
                    reporter: row['上报人'] || '匿名',
                    time: row['上报时间'] || '未知',
                    note: row['备注'] || '无'
                };

                processedData.push(processed);
            });

            return processedData;
        }

        /**
         * 加载Excel数据
         */
        async function loadExcelData() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('❌ 请先选择Excel文件', 'error');
                return;
            }

            if (!map) {
                showMessage('❌ 请先等待地图加载完成', 'error');
                return;
            }

            try {
                showMessage('📊 正在解析Excel文件...', 'info');
                
                // 解析Excel文件
                const excelData = await parseExcelFile(file);
                console.log('Excel数据:', excelData);

                // 处理数据
                const processedData = processExcelData(excelData);
                
                if (processedData.length === 0) {
                    showMessage('❌ 未找到有效的数据行', 'error');
                    return;
                }

                // 更新当前数据并显示在地图上
                currentData = processedData;
                addSignalMarkers(currentData);
                
                showMessage(`✅ 成功导入 ${processedData.length} 条数据记录`);

            } catch (error) {
                console.error('Excel处理错误:', error);
                showMessage(`❌ Excel文件处理失败: ${error.message}`, 'error');
            }
        }

        /**
         * 初始化控制面板
         */
        function initControls() {
            console.log('🎛️ 初始化控制面板...');
            
            // 热力图开关
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch) {
                heatmapSwitch.addEventListener('change', function() {
                    console.log('热力图开关状态:', this.checked);
                    if (this.checked) {
                        showHeatmap();
                    } else {
                        hideHeatmap();
                    }
                });
                console.log('✅ 热力图开关事件绑定成功');
            } else {
                console.error('❌ 找不到热力图开关元素');
            }

            // 标记点开关
            const markersSwitch = document.getElementById('markersSwitch');
            if (markersSwitch) {
                markersSwitch.addEventListener('change', function() {
                    console.log('标记点开关状态:', this.checked);
                    if (this.checked) {
                        showMarkers();
                    } else {
                        hideMarkers();
                    }
                });
                console.log('✅ 标记点开关事件绑定成功');
            } else {
                console.error('❌ 找不到标记点开关元素');
            }

            // 强度滑块
            const intensitySlider = document.getElementById('intensitySlider');
            const intensityValue = document.getElementById('intensityValue');
            
            if (intensitySlider && intensityValue) {
                // 设置初始值
                intensityValue.textContent = intensitySlider.value;
                
                intensitySlider.addEventListener('input', function() {
                    intensityValue.textContent = this.value;
                    // 只有在有数据时才进行筛选
                    if (currentData && currentData.length > 0) {
                        filterByIntensity(parseInt(this.value));
                    }
                });
                console.log('✅ 强度滑块事件绑定成功，初始值:', intensitySlider.value);
            } else {
                console.error('❌ 找不到强度滑块元素');
            }
        }

        /**
         * 生成基于实际监测点位置的热力图数据
         * 确保热力图和标记点位置完全一致
         */
        function generateHeatmapData(data) {
            const heatData = [];
            
            console.log('🗺️ 生成基于实际监测点的热力图...');
            
            // 直接使用监测点的实际位置，不进行聚合
            data.forEach((point, index) => {
                // 根据信号强度计算热力值 (信号越差，热力值越高)
                const baseHeatValue = Math.max(20, (11 - point.signal) * 30);
                
                // 为每个监测点生成一个小的热力区域
                const heatPoints = generatePointHeatArea(
                    point.position[0], 
                    point.position[1], 
                    point.signal
                );
                
                heatData.push(...heatPoints);
                
                if (index < 10) { // 只打印前10个点的详细信息
                    console.log(`🔥 点${index + 1}: 信号${point.signal}, 位置[${point.position[0].toFixed(3)}, ${point.position[1].toFixed(3)}], 热力值${baseHeatValue}`);
                }
            });
            
            console.log(`🔥 基于${data.length}个实际监测点生成${heatData.length}个热力点`);
            return heatData;
        }
        
        /**
         * 计算两点间距离 (用于其他功能)
         */
        function calculateDistance(pos1, pos2) {
            return Math.sqrt(
                Math.pow(pos1[0] - pos2[0], 2) + 
                Math.pow(pos1[1] - pos2[1], 2)
            );
        }

        /**
         * 计算聚类中心点 (用于智能分析)
         */
        function calculateClusterCenter(cluster) {
            const sumLng = cluster.reduce((sum, point) => sum + point.position[0], 0);
            const sumLat = cluster.reduce((sum, point) => sum + point.position[1], 0);
            return [sumLng / cluster.length, sumLat / cluster.length];
        }
        
        /**
         * 为单个监测点生成热力区域
         * 确保热力图位置与标记点位置完全一致
         */
        function generatePointHeatArea(centerLng, centerLat, signal) {
            const points = [];
            
            // 根据信号强度确定热力区域参数
            const baseRadius = 0.008; // 固定基础半径约800米
            const heatRadius = baseRadius * (1 + (10 - signal) * 0.15); // 信号越差，影响范围稍大
            
            // 信号强度转换为热力值 (信号越差，热力值越高，在热力图中越红)
            const baseHeatValue = Math.max(15, (11 - signal) * 20);
            
            // 中心点 - 使用实际监测点位置
            points.push({
                lng: centerLng,
                lat: centerLat,
                count: baseHeatValue
            });
            
            // 生成围绕监测点的小热力区域
            const layers = 3; // 减少层数，保持热力图紧凑
            const pointsPerLayer = 6; // 每层6个点
            
            for (let layer = 1; layer <= layers; layer++) {
                const layerRadius = (heatRadius * layer) / layers;
                const layerHeatValue = baseHeatValue * Math.pow(0.6, layer);
                
                for (let i = 0; i < pointsPerLayer; i++) {
                    const angle = (i * 2 * Math.PI) / pointsPerLayer;
                    
                    // 轻微的随机偏移，保持自然感
                    const radiusVariation = 0.7 + Math.random() * 0.6; // 0.7-1.3的变化
                    const actualRadius = layerRadius * radiusVariation;
                    
                    const lng = centerLng + actualRadius * Math.cos(angle);
                    const lat = centerLat + actualRadius * Math.sin(angle);
                    
                    points.push({
                        lng: lng,
                        lat: lat,
                        count: Math.max(5, layerHeatValue)
                    });
                }
            }
            
            return points;
        }

        /**
         * 显示热力图
         */
        function showHeatmap() {
            console.log('🔥 开始显示热力图...');
            
            if (!currentData || currentData.length === 0) {
                showMessage('❌ 请先导入数据', 'error');
                document.getElementById('heatmapSwitch').checked = false;
                return;
            }

            if (heatmapLayer) {
                console.log('清除现有热力图...');
                hideHeatmap();
            }

            try {
                // 检查AMap.HeatMap是否可用
                if (typeof AMap === 'undefined' || !AMap.HeatMap) {
                    throw new Error('高德地图热力图插件未加载');
                }

                const heatData = generateHeatmapData(currentData);
                console.log('热力图数据:', heatData);
                
                heatmapLayer = new AMap.HeatMap(map, {
                    radius: 25, // 较小半径适合单点监测数据
                    opacity: [0.3, 0.7], // 适中透明度保持标记点可见
                    gradient: {
                        '0.0': '#0066ff',  // 信号好 - 深蓝色
                        '0.2': '#0088ff',  // 信号较好 - 蓝色
                        '0.4': '#00ff88',  // 信号一般 - 绿色
                        '0.6': '#ffff00',  // 信号较差 - 黄色  
                        '0.8': '#ff8800',  // 信号差 - 橙色
                        '1.0': '#ff0000'   // 信号盲区 - 红色
                    },
                    blur: 0.8, // 适度模糊让热力图自然过渡
                    max: 200   // 设置最大热力值适应单点数据
                });
                
                // 计算数据中的最大权重值
                const maxWeight = Math.max(...heatData.map(item => item.count));
                console.log('热力图最大权重值:', maxWeight);
                
                heatmapLayer.setDataSet({
                    data: heatData,
                    max: maxWeight || 100 // 使用实际最大值或默认100
                });

                console.log('✅ 热力图显示成功');
                showMessage('🔥 热力图已开启，位置与标记点完全一致，红色区域为信号盲区');
                
            } catch (error) {
                console.error('❌ 热力图显示失败:', error);
                showMessage(`❌ 热力图显示失败: ${error.message}`, 'error');
                document.getElementById('heatmapSwitch').checked = false;
            }
        }

        /**
         * 隐藏热力图
         */
        function hideHeatmap() {
            console.log('🌫️ 隐藏热力图...');
            if (heatmapLayer) {
                try {
                    heatmapLayer.hide();
                    heatmapLayer.setMap(null);
                    heatmapLayer = null;
                    console.log('✅ 热力图已隐藏');
                    showMessage('✅ 热力图已关闭');
                } catch (error) {
                    console.error('隐藏热力图失败:', error);
                }
            } else {
                console.log('热力图不存在，无需隐藏');
            }
        }

        /**
         * 显示标记点
         */
        function showMarkers() {
            console.log('📍 显示标记点...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.show();
                });
                console.log('✅ 标记点已显示');
                showMessage('📍 标记点已显示');
            }
        }

        /**
         * 隐藏标记点
         */
        function hideMarkers() {
            console.log('📍 隐藏标记点...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.hide();
                });
                console.log('✅ 标记点已隐藏');
                showMessage('📍 标记点已隐藏');
            }
        }

        /**
         * 根据信号强度筛选显示
         */
        function filterByIntensity(maxIntensity) {
            if (!currentData || currentData.length === 0) return;
            
            // 筛选数据
            const filteredData = currentData.filter(point => point.signal <= maxIntensity);
            
            // 清除现有标记
            clearMarkers();
            
            // 重新添加符合条件的标记 (使用筛选后的数据，但不改变currentData)
            const displayData = filteredData;
            
            // 采样显示逻辑 (从addSignalMarkers函数复制过来)
            let finalDisplayData = displayData;
            const MAX_MARKERS = 200;
            
            if (displayData.length > MAX_MARKERS) {
                const severeBlinds = displayData.filter(p => p.signal <= 2);
                const poor = displayData.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = displayData.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = displayData.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                finalDisplayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
            }
            
            // 添加标记
            finalDisplayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - 信号强度: ${point.signal}/10 (${getSignalDescription(point.signal)})`,
                    icon: icon
                });

                map.add(marker);
                markers.push(marker);
            });
            
            // 更新信息面板
            updateInfoPanel(filteredData);
            
            // 更新热力图 (如果开启了热力图)
            if (heatmapLayer) {
                // 直接用筛选后的数据更新热力图
                const heatData = generateHeatmapData(filteredData);
                heatmapLayer.setDataSet({
                    data: heatData,
                    max: Math.max(...heatData.map(item => item.count)) || 100
                });
            }
            
            showMessage(`🔍 显示信号强度 ≤ ${maxIntensity} 的监测点 (${filteredData.length} 个)`);
        }

        /**
         * 更新热力图 (数据变化时调用)
         */
        function updateHeatmap() {
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch && heatmapSwitch.checked) {
                hideHeatmap();
                setTimeout(showHeatmap, 100);
            }
        }

        /**
         * 测试热力图功能
         */
        function testHeatmap() {
            console.log('🧪 测试热力图功能...');
            console.log('AMap对象:', typeof AMap);
            console.log('AMap.HeatMap对象:', typeof AMap.HeatMap);
            console.log('地图对象:', map);
            console.log('当前数据:', currentData);
            console.log('热力图层:', heatmapLayer);
            
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            console.log('热力图开关元素:', heatmapSwitch);
            console.log('开关状态:', heatmapSwitch ? heatmapSwitch.checked : '元素不存在');
            
            // 手动测试热力图开关
            if (heatmapSwitch) {
                console.log('点击开关进行测试...');
                heatmapSwitch.click();
            }
        }

        /**
         * 手动触发热力图显示（调试用）
         */
        function manualShowHeatmap() {
            console.log('🔥 手动触发热力图显示...');
            if (currentData.length === 0) {
                useDefaultData();
                setTimeout(() => {
                    showHeatmap();
                }, 1000);
            } else {
                showHeatmap();
            }
        }

        /**
         * 手动触发热力图隐藏（调试用）
         */
        function manualHideHeatmap() {
            console.log('🌫️ 手动触发热力图隐藏...');
            hideHeatmap();
        }

        // 页面加载完成后初始化地图
        window.onload = function() {
            console.log('🚀 页面加载完成，开始初始化...');
            initMap();
            
            // 5秒后测试热力图功能（给地图时间加载）
            setTimeout(testHeatmap, 5000);
            
            // 添加全局调试函数
            window.debugAnalysis = function() {
                console.log('🔧 开始调试智能分析...');
                console.log('当前数据:', currentData);
                console.log('KMeansCluster类:', KMeansCluster);
                console.log('blindSpotDetector:', blindSpotDetector);
                console.log('signalPredictor:', signalPredictor);
                
                if (currentData && currentData.length > 0) {
                    console.log('数据样例:', currentData[0]);
                    try {
                        const basicStats = calculateBasicStatistics(currentData);
                        console.log('基础统计测试通过:', basicStats);
                    } catch (e) {
                        console.error('基础统计测试失败:', e);
                    }
                }
            };
            
            console.log('💡 可以在浏览器控制台输入 debugAnalysis() 进行调试');
        };

        // =====================================
        // 高级算法模块 - 提升技术价值
        // =====================================

        /**
         * K-means聚类算法实现
         * @description 使用K-means算法对信号监测点进行智能聚类
         * @param {Array} data - 监测点数据
         * @param {number} k - 聚类数量
         * @returns {Array} 聚类结果
         */
        class KMeansCluster {
            constructor(k = 8) {
                this.k = k;
                this.maxIterations = 100;
                this.tolerance = 0.001;
            }

            /**
             * 执行K-means聚类
             */
            cluster(data) {
                if (data.length < this.k) {
                    return data.map(point => ({ ...point, cluster: 0 }));
                }

                // 1. 初始化聚类中心
                let centroids = this.initializeCentroids(data);
                let previousCentroids;
                let iterations = 0;

                do {
                    previousCentroids = centroids.map(c => ({ ...c }));
                    
                    // 2. 分配数据点到最近的聚类中心
                    const clusters = this.assignPointsToCentroids(data, centroids);
                    
                    // 3. 更新聚类中心
                    centroids = this.updateCentroids(clusters);
                    
                    iterations++;
                } while (
                    iterations < this.maxIterations && 
                    !this.hasConverged(centroids, previousCentroids)
                );

                console.log(`🧮 K-means聚类完成，迭代${iterations}次，生成${centroids.length}个聚类中心`);
                
                return this.assignPointsToCentroids(data, centroids);
            }

            /**
             * 随机初始化聚类中心
             */
            initializeCentroids(data) {
                const centroids = [];
                const used = new Set();
                
                for (let i = 0; i < this.k; i++) {
                    let randomIndex;
                    do {
                        randomIndex = Math.floor(Math.random() * data.length);
                    } while (used.has(randomIndex));
                    
                    used.add(randomIndex);
                    centroids.push({
                        lng: data[randomIndex].position[0],
                        lat: data[randomIndex].position[1],
                        signal: data[randomIndex].signal
                    });
                }
                
                return centroids;
            }

            /**
             * 将数据点分配到最近的聚类中心
             */
            assignPointsToCentroids(data, centroids) {
                return data.map(point => {
                    let minDistance = Infinity;
                    let closestCentroid = 0;
                    
                    centroids.forEach((centroid, index) => {
                        const distance = this.calculateDistance(
                            point.position, 
                            [centroid.lng, centroid.lat]
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCentroid = index;
                        }
                    });
                    
                    return { ...point, cluster: closestCentroid, distance: minDistance };
                });
            }

            /**
             * 更新聚类中心
             */
            updateCentroids(clusteredData) {
                const centroids = [];
                
                for (let i = 0; i < this.k; i++) {
                    const clusterPoints = clusteredData.filter(point => point.cluster === i);
                    
                    if (clusterPoints.length === 0) continue;
                    
                    const avgLng = clusterPoints.reduce((sum, p) => sum + p.position[0], 0) / clusterPoints.length;
                    const avgLat = clusterPoints.reduce((sum, p) => sum + p.position[1], 0) / clusterPoints.length;
                    const avgSignal = clusterPoints.reduce((sum, p) => sum + p.signal, 0) / clusterPoints.length;
                    
                    centroids.push({
                        lng: avgLng,
                        lat: avgLat,
                        signal: avgSignal
                    });
                }
                
                return centroids;
            }

            /**
             * 检查是否收敛
             */
            hasConverged(current, previous) {
                return current.every((centroid, index) => {
                    if (!previous[index]) return false;
                    
                    const distance = this.calculateDistance(
                        [centroid.lng, centroid.lat],
                        [previous[index].lng, previous[index].lat]
                    );
                    
                    return distance < this.tolerance;
                });
            }

            /**
             * 计算两点间欧几里得距离
             */
            calculateDistance(pos1, pos2) {
                return Math.sqrt(
                    Math.pow(pos1[0] - pos2[0], 2) + 
                    Math.pow(pos1[1] - pos2[1], 2)
                );
            }
        }

        /**
         * 信号覆盖预测算法
         * @description 基于现有监测点，使用插值算法预测未监测区域的信号强度
         */
        class SignalPredictor {
            constructor() {
                this.influenceRadius = 0.1; // 影响半径（度）
                this.weightPower = 2; // 反距离权重幂次
            }

            /**
             * 使用反距离权重插值预测信号强度
             * @param {Array} knownPoints - 已知监测点
             * @param {Array} targetPosition - 目标位置 [lng, lat]
             * @returns {number} 预测的信号强度
             */
            predictSignalStrength(knownPoints, targetPosition) {
                if (knownPoints.length === 0) return 5; // 默认值

                let weightedSum = 0;
                let totalWeight = 0;

                for (const point of knownPoints) {
                    const distance = this.calculateDistance(targetPosition, point.position);
                    
                    // 如果距离太远，则不考虑其影响
                    if (distance > this.influenceRadius) continue;
                    
                    // 避免除零错误
                    if (distance < 0.0001) return point.signal;
                    
                    const weight = 1 / Math.pow(distance, this.weightPower);
                    weightedSum += weight * point.signal;
                    totalWeight += weight;
                }

                return totalWeight > 0 ? weightedSum / totalWeight : 5;
            }

            /**
             * 生成信号覆盖预测网格
             * @param {Array} knownPoints - 已知监测点
             * @param {Object} bounds - 区域边界
             * @param {number} gridSize - 网格密度
             * @returns {Array} 预测网格数据
             */
            generatePredictionGrid(knownPoints, bounds, gridSize = 30) {
                const grid = [];
                const lngStep = (bounds.maxLng - bounds.minLng) / gridSize;
                const latStep = (bounds.maxLat - bounds.minLat) / gridSize;

                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize; j++) {
                        const lng = bounds.minLng + i * lngStep;
                        const lat = bounds.minLat + j * latStep;
                        
                        const predictedSignal = this.predictSignalStrength(
                            knownPoints, 
                            [lng, lat]
                        );

                        grid.push({
                            position: [lng, lat],
                            signal: predictedSignal,
                            confidence: this.calculateConfidence(knownPoints, [lng, lat])
                        });
                    }
                }

                console.log(`🎯 生成${grid.length}个预测点的信号覆盖网格`);
                return grid;
            }

            /**
             * 计算预测置信度
             */
            calculateConfidence(knownPoints, targetPosition) {
                const nearbyPoints = knownPoints.filter(point => {
                    const distance = this.calculateDistance(targetPosition, point.position);
                    return distance <= this.influenceRadius;
                });

                // 置信度基于附近监测点的数量和距离
                const confidence = Math.min(1, nearbyPoints.length / 5);
                return confidence;
            }

            calculateDistance(pos1, pos2) {
                return Math.sqrt(
                    Math.pow(pos1[0] - pos2[0], 2) + 
                    Math.pow(pos1[1] - pos2[1], 2)
                );
            }
        }

        /**
         * 盲区检测算法
         * @description 使用凸包算法和密度分析识别信号盲区
         */
        class BlindSpotDetector {
            constructor() {
                this.blindSpotThreshold = 3; // 盲区信号强度阈值
                this.minDensity = 0.1; // 最小密度阈值
            }

            /**
             * 检测潜在的信号盲区
             * @param {Array} data - 监测点数据
             * @returns {Array} 盲区区域
             */
            detectBlindSpots(data) {
                // 1. 筛选出信号较差的点
                const weakSignalPoints = data.filter(point => 
                    point.signal <= this.blindSpotThreshold
                );

                if (weakSignalPoints.length < 3) {
                    return [];
                }

                // 2. 对弱信号点进行聚类
                const kmeans = new KMeansCluster(Math.min(5, Math.floor(weakSignalPoints.length / 3)));
                const clusteredPoints = kmeans.cluster(weakSignalPoints);

                // 3. 为每个聚类生成盲区边界
                const blindSpots = [];
                const clusterMap = new Map();

                clusteredPoints.forEach(point => {
                    if (!clusterMap.has(point.cluster)) {
                        clusterMap.set(point.cluster, []);
                    }
                    clusterMap.get(point.cluster).push(point);
                });

                clusterMap.forEach((points, clusterId) => {
                    if (points.length >= 3) { // 至少3个点才能形成区域
                        const boundary = this.generateBlindSpotBoundary(points);
                        blindSpots.push({
                            id: clusterId,
                            points: points,
                            boundary: boundary,
                            avgSignal: points.reduce((sum, p) => sum + p.signal, 0) / points.length,
                            area: this.calculateArea(boundary),
                            severity: this.calculateSeverity(points)
                        });
                    }
                });

                console.log(`🔍 检测到${blindSpots.length}个潜在盲区`);
                return blindSpots;
            }

            /**
             * 生成盲区边界（简化凸包算法）
             */
            generateBlindSpotBoundary(points) {
                if (points.length < 3) return [];

                // 找到最左下角的点作为起点
                let start = points.reduce((min, point) => {
                    if (point.position[1] < min.position[1] || 
                        (point.position[1] === min.position[1] && point.position[0] < min.position[0])) {
                        return point;
                    }
                    return min;
                });

                // 使用Graham扫描算法的简化版本
                const sortedPoints = points
                    .filter(p => p !== start)
                    .sort((a, b) => {
                        const angleA = Math.atan2(a.position[1] - start.position[1], a.position[0] - start.position[0]);
                        const angleB = Math.atan2(b.position[1] - start.position[1], b.position[0] - start.position[0]);
                        return angleA - angleB;
                    });

                const hull = [start];
                for (const point of sortedPoints) {
                    while (hull.length > 1 && this.crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                        hull.pop();
                    }
                    hull.push(point);
                }

                return hull.map(p => p.position);
            }

            /**
             * 计算叉积（用于凸包算法）
             */
            crossProduct(o, a, b) {
                return (a.position[0] - o.position[0]) * (b.position[1] - o.position[1]) - 
                       (a.position[1] - o.position[1]) * (b.position[0] - o.position[0]);
            }

            /**
             * 计算区域面积
             */
            calculateArea(boundary) {
                if (boundary.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < boundary.length; i++) {
                    const j = (i + 1) % boundary.length;
                    area += boundary[i][0] * boundary[j][1];
                    area -= boundary[j][0] * boundary[i][1];
                }
                return Math.abs(area) / 2;
            }

            /**
             * 计算盲区严重程度
             */
            calculateSeverity(points) {
                const avgSignal = points.reduce((sum, p) => sum + p.signal, 0) / points.length;
                const density = points.length;
                
                // 综合信号强度和密度计算严重程度
                return Math.max(0, Math.min(10, (4 - avgSignal) * density * 0.5));
            }
        }

        // =====================================
        // 实例化高级算法类
        // =====================================
        const signalPredictor = new SignalPredictor();
        const blindSpotDetector = new BlindSpotDetector();

        // =====================================
        // 智能分析功能模块
        // =====================================

        /**
         * 执行智能分析
         * @description 综合运用多种算法分析信号覆盖状况
         */
        async function runSmartAnalysis() {
            if (!currentData || currentData.length === 0) {
                showMessage('❌ 请先导入数据', 'error');
                return;
            }

            showMessage('🧠 正在进行智能分析...', 'info');
            console.log('🧠 开始智能分析，数据点数量:', currentData.length);
            
            try {
                // 1. 基础统计分析
                console.log('📊 执行基础统计分析...');
                const basicStats = calculateBasicStatistics(currentData);
                console.log('基础统计完成:', basicStats);
                
                // 2. 聚类分析
                console.log('🎯 执行聚类分析...');
                const kmeans = new KMeansCluster(6);
                const clusteredData = kmeans.cluster(currentData);
                const clusterAnalysis = analyzeClusterDistribution(clusteredData);
                console.log('聚类分析完成:', clusterAnalysis);
                
                // 3. 盲区检测
                console.log('🔍 执行盲区检测...');
                const blindSpots = blindSpotDetector.detectBlindSpots(currentData);
                console.log('盲区检测完成:', blindSpots);
                
                // 4. 信号分布分析
                console.log('📡 执行信号分布分析...');
                const distributionAnalysis = analyzeSignalDistribution(currentData);
                console.log('信号分布分析完成:', distributionAnalysis);
                
                // 5. 覆盖质量评估
                console.log('⭐ 执行覆盖质量评估...');
                const coverageQuality = assessCoverageQuality(currentData);
                console.log('覆盖质量评估完成:', coverageQuality);
                
                // 6. 优化建议
                console.log('💡 生成优化建议...');
                const recommendations = generateRecommendations({
                    basicStats,
                    clusterAnalysis,
                    blindSpots,
                    distributionAnalysis,
                    coverageQuality
                });
                console.log('优化建议生成完成:', recommendations);

                // 显示分析结果
                console.log('📋 显示分析结果...');
                displayAnalysisResults({
                    basicStats,
                    clusterAnalysis,
                    blindSpots,
                    distributionAnalysis,
                    coverageQuality,
                    recommendations
                });

                console.log('✅ 智能分析全部完成');
                showMessage('✅ 智能分析完成', 'success');
                
            } catch (error) {
                console.error('❌ 智能分析失败详细信息:', error);
                console.error('错误堆栈:', error.stack);
                console.error('当前数据状态:', currentData);
                
                // 显示具体错误信息
                const errorMsg = error.message || '未知错误';
                showMessage(`❌ 智能分析失败: ${errorMsg}`, 'error');
                
                // 尝试显示部分结果（如果有的话）
                try {
                    const basicStats = calculateBasicStatistics(currentData);
                    if (basicStats) {
                        console.log('部分统计结果:', basicStats);
                        showMessage('⚠️ 部分分析结果可用，请查看控制台', 'warning');
                    }
                } catch (e) {
                    console.error('连基础统计都失败:', e);
                }
            }
        }

        /**
         * 计算基础统计信息
         */
        function calculateBasicStatistics(data) {
            const signals = data.map(d => d.signal);
            const total = signals.length;
            const sum = signals.reduce((a, b) => a + b, 0);
            const avg = sum / total;
            
            const sortedSignals = [...signals].sort((a, b) => a - b);
            const median = total % 2 === 0 
                ? (sortedSignals[total/2 - 1] + sortedSignals[total/2]) / 2
                : sortedSignals[Math.floor(total/2)];
            
            const variance = signals.reduce((sum, signal) => sum + Math.pow(signal - avg, 2), 0) / total;
            const stdDev = Math.sqrt(variance);
            
            const severeBlinds = data.filter(d => d.signal <= 2).length;
            const poorSignal = data.filter(d => d.signal >= 3 && d.signal <= 4).length;
            const normalSignal = data.filter(d => d.signal >= 5 && d.signal <= 6).length;
            const goodSignal = data.filter(d => d.signal >= 7).length;

            return {
                total,
                average: avg,
                median,
                standardDeviation: stdDev,
                minimum: Math.min(...signals),
                maximum: Math.max(...signals),
                severeBlinds,
                poorSignal,
                normalSignal,
                goodSignal,
                severeBlindRate: (severeBlinds / total * 100),
                goodSignalRate: (goodSignal / total * 100)
            };
        }

        /**
         * 分析聚类分布
         */
        function analyzeClusterDistribution(clusteredData) {
            const clusterMap = new Map();
            
            clusteredData.forEach(point => {
                if (!clusterMap.has(point.cluster)) {
                    clusterMap.set(point.cluster, []);
                }
                clusterMap.get(point.cluster).push(point);
            });

            const clusters = [];
            clusterMap.forEach((points, clusterId) => {
                const avgSignal = points.reduce((sum, p) => sum + p.signal, 0) / points.length;
                const center = calculateClusterCenter(points);
                
                clusters.push({
                    id: clusterId,
                    size: points.length,
                    avgSignal: avgSignal,
                    center: center,
                    quality: avgSignal >= 7 ? '优秀' : avgSignal >= 5 ? '良好' : avgSignal >= 3 ? '一般' : '差'
                });
            });

            return {
                clusterCount: clusters.length,
                clusters: clusters,
                avgClusterSize: clusters.reduce((sum, c) => sum + c.size, 0) / clusters.length,
                bestCluster: clusters.reduce((best, current) => 
                    current.avgSignal > best.avgSignal ? current : best
                ),
                worstCluster: clusters.reduce((worst, current) => 
                    current.avgSignal < worst.avgSignal ? current : worst
                )
            };
        }

        /**
         * 分析信号分布
         */
        function analyzeSignalDistribution(data) {
            const networkTypes = {};
            data.forEach(point => {
                if (!networkTypes[point.network]) {
                    networkTypes[point.network] = { count: 0, totalSignal: 0 };
                }
                networkTypes[point.network].count++;
                networkTypes[point.network].totalSignal += point.signal;
            });

            // 计算各网络类型的平均信号强度
            Object.keys(networkTypes).forEach(type => {
                networkTypes[type].avgSignal = networkTypes[type].totalSignal / networkTypes[type].count;
            });

            // 地理分布分析
            const bounds = {
                minLng: Math.min(...data.map(d => d.position[0])),
                maxLng: Math.max(...data.map(d => d.position[0])),
                minLat: Math.min(...data.map(d => d.position[1])),
                maxLat: Math.max(...data.map(d => d.position[1]))
            };

            const coverage = {
                longitudeSpan: bounds.maxLng - bounds.minLng,
                latitudeSpan: bounds.maxLat - bounds.minLat,
                centerPoint: [(bounds.minLng + bounds.maxLng) / 2, (bounds.minLat + bounds.maxLat) / 2]
            };

            return {
                networkTypes,
                coverage,
                bounds
            };
        }

        /**
         * 评估覆盖质量
         */
        function assessCoverageQuality(data) {
            const basicStats = calculateBasicStatistics(data);
            
            // 计算覆盖质量得分 (0-100)
            let qualityScore = 0;
            
            // 平均信号强度权重 40%
            qualityScore += (basicStats.average / 10) * 40;
            
            // 严重盲区率权重 30% (越少越好)
            qualityScore += (1 - basicStats.severeBlindRate / 100) * 30;
            
            // 信号稳定性权重 20% (标准差越小越好，最大10分)
            const stabilityScore = Math.max(0, 10 - basicStats.standardDeviation) / 10;
            qualityScore += stabilityScore * 20;
            
            // 好信号比例权重 10%
            qualityScore += (basicStats.goodSignalRate / 100) * 10;

            // 确定质量等级
            let qualityGrade;
            if (qualityScore >= 85) qualityGrade = 'A+ 优秀';
            else if (qualityScore >= 75) qualityGrade = 'A 良好';
            else if (qualityScore >= 65) qualityGrade = 'B+ 中上';
            else if (qualityScore >= 55) qualityGrade = 'B 中等';
            else if (qualityScore >= 45) qualityGrade = 'C+ 中下';
            else if (qualityScore >= 35) qualityGrade = 'C 较差';
            else qualityGrade = 'D 差';

            return {
                score: qualityScore,
                grade: qualityGrade,
                strengths: [],
                weaknesses: []
            };
        }

        /**
         * 生成优化建议
         */
        function generateRecommendations(analysisData) {
            const recommendations = [];
            const { basicStats, blindSpots, coverageQuality } = analysisData;

            // 基于盲区数量的建议
            if (basicStats.severeBlindRate > 20) {
                recommendations.push({
                    type: 'critical',
                    title: '严重盲区过多',
                    description: `检测到${basicStats.severeBlinds}个严重盲区（${basicStats.severeBlindRate.toFixed(1)}%），建议优先部署基站`,
                    priority: 'high'
                });
            }

            // 基于信号质量的建议
            if (basicStats.average < 5) {
                recommendations.push({
                    type: 'warning',
                    title: '整体信号质量偏低',
                    description: '平均信号强度仅为' + basicStats.average.toFixed(1) + '分，建议全面优化网络覆盖',
                    priority: 'high'
                });
            }

            // 基于盲区分布的建议
            if (blindSpots.length > 0) {
                recommendations.push({
                    type: 'info',
                    title: '盲区聚集分析',
                    description: `发现${blindSpots.length}个盲区聚集区域，建议针对性部署小基站或中继设备`,
                    priority: 'medium'
                });
            }

            // 基于覆盖质量的建议
            if (coverageQuality.score < 60) {
                recommendations.push({
                    type: 'warning',
                    title: '网络覆盖质量需要改善',
                    description: `当前覆盖质量得分${coverageQuality.score.toFixed(1)}分，等级${coverageQuality.grade}`,
                    priority: 'medium'
                });
            }

            return recommendations;
        }

        /**
         * 显示分析结果
         */
        function displayAnalysisResults(results) {
            const { basicStats, clusterAnalysis, blindSpots, coverageQuality, recommendations } = results;
            
            const content = `
                <div class="analysis-item">
                    <h5>📊 基础统计</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">监测点总数</span>
                        <span class="metric-value">${basicStats.total}</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">平均信号强度</span>
                        <span class="metric-value">${basicStats.average.toFixed(2)}/10</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">严重盲区</span>
                        <span class="metric-value">${basicStats.severeBlinds} (${basicStats.severeBlindRate.toFixed(1)}%)</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">信号稳定性</span>
                        <span class="metric-value">σ = ${basicStats.standardDeviation.toFixed(2)}</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>🎯 聚类分析</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">聚类数量</span>
                        <span class="metric-value">${clusterAnalysis.clusterCount}</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">平均聚类大小</span>
                        <span class="metric-value">${clusterAnalysis.avgClusterSize.toFixed(0)}个点</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">最佳聚类信号</span>
                        <span class="metric-value">${clusterAnalysis.bestCluster.avgSignal.toFixed(1)}/10</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>🔍 盲区检测</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">检测到盲区</span>
                        <span class="metric-value">${blindSpots.length}个</span>
                    </div>
                    ${blindSpots.length > 0 ? `
                    <div class="analysis-metric">
                        <span class="metric-label">最严重盲区</span>
                        <span class="metric-value">严重度 ${Math.max(...blindSpots.map(b => b.severity)).toFixed(1)}</span>
                    </div>` : ''}
                </div>

                <div class="analysis-item">
                    <h5>⭐ 覆盖质量评估</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">质量得分</span>
                        <span class="metric-value">${coverageQuality.score.toFixed(1)}/100</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">质量等级</span>
                        <span class="metric-value">${coverageQuality.grade}</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>💡 优化建议</h5>
                    ${recommendations.map(rec => `
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                            <strong>${rec.title}</strong><br>
                            <small>${rec.description}</small>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('analysisContent').innerHTML = content;
            document.getElementById('analysisResults').style.display = 'block';
        }

        /**
         * 预测信号覆盖
         */
        function predictSignalCoverage() {
            if (!currentData || currentData.length === 0) {
                showMessage('❌ 请先导入数据', 'error');
                return;
            }

            showMessage('🔮 正在进行信号覆盖预测...', 'info');

            try {
                // 计算预测区域边界
                const bounds = {
                    minLng: Math.min(...currentData.map(d => d.position[0])) - 0.05,
                    maxLng: Math.max(...currentData.map(d => d.position[0])) + 0.05,
                    minLat: Math.min(...currentData.map(d => d.position[1])) - 0.05,
                    maxLat: Math.max(...currentData.map(d => d.position[1])) + 0.05
                };

                // 生成预测网格
                const predictionGrid = signalPredictor.generatePredictionGrid(currentData, bounds, 25);
                
                // 将预测结果叠加到热力图
                updateHeatmapWithPrediction(predictionGrid);
                
                showMessage('✅ 信号覆盖预测完成，预测结果已显示在热力图中', 'success');
                
                // 自动开启热力图显示
                document.getElementById('heatmapSwitch').checked = true;
                showHeatmap();
                
            } catch (error) {
                console.error('信号预测失败:', error);
                showMessage('❌ 信号预测失败', 'error');
            }
        }

        /**
         * 更新热力图包含预测数据
         */
        function updateHeatmapWithPrediction(predictionGrid) {
            // 这里可以将预测数据与实际数据结合
            // 为了演示，我们将预测数据添加到当前数据中
            const combinedData = [...currentData];
            
            // 添加高置信度的预测点
            predictionGrid.forEach(pred => {
                if (pred.confidence > 0.5) { // 只添加高置信度的预测
                    combinedData.push({
                        position: pred.position,
                        signal: pred.signal,
                        isPredicted: true
                    });
                }
            });

            console.log(`🔮 结合${predictionGrid.length}个预测点进行热力图更新`);
            
            // 重新生成热力图
            const heatData = generateHeatmapData(combinedData);
            
            if (heatmapLayer) {
                heatmapLayer.setDataSet({ data: heatData, max: 200 });
            }
        }
    </script>
</body>
</html> 