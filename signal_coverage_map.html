<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å—é€šå¸‚ä¿¡å·è¦†ç›–åœ°å›¾</title>
    <style>
        /* é¡µé¢æ•´ä½“æ ·å¼ */
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background-color: #f8f9fa;
        }

        /* æ ‡é¢˜åŒºåŸŸ */
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .header h1 {
            margin: 0;
            font-size: 24px;
        }

        .header p {
            margin: 8px 0 0 0;
            opacity: 0.9;
        }

        /* æ§åˆ¶é¢æ¿æ ·å¼ */
        .control-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
            cursor: pointer;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin: 0;
            padding: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
            pointer-events: auto;
            user-select: none;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #667eea;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .intensity-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .intensity-slider {
            width: 150px;
        }

        /* æ–‡ä»¶å¯¼å…¥é¢æ¿ */
        .import-panel {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .file-input {
            flex: 1;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .file-input:hover {
            border-color: #667eea;
        }

        .btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5a6fd8;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* ä¿¡æ¯é¢æ¿ */
        .info-panel {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* åœ°å›¾å®¹å™¨ */
        #map {
            width: 100%;
            height: 500px;
            border: 2px solid #dee2e6;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        /* å›¾ä¾‹æ ·å¼ */
        .legend {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            border: 1px solid #dee2e6;
        }

        .legend h4 {
            margin: 0 0 10px 0;
            color: #333;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 8px 0;
        }

        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 10px;
        }

        .red { background-color: #ff0000; }
        .orange { background-color: #ff8800; }
        .green { background-color: #00bb00; }
        .blue { background-color: #0088ff; }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            text-align: center;
            padding: 20px;
            color: #666;
        }

        .status-message {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }

        .info {
            background: #cce7ff;
            color: #0066cc;
            border: 1px solid #99ccff;
        }

        .analysis-panel {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 15px;
            padding: 20px;
            margin-top: 15px;
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.3);
        }

        .analysis-panel h4 {
            margin-top: 0;
            color: #fff;
            font-size: 18px;
        }

        .analysis-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 12px;
            margin: 10px 0;
            backdrop-filter: blur(10px);
        }

        .analysis-metric {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 8px 0;
        }

        .metric-label {
            font-weight: 500;
        }

        .metric-value {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 12px;
            border-radius: 20px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- é¡µé¢æ ‡é¢˜ -->
    <div class="header">
        <h1>ğŸ—ºï¸ å—é€šå¸‚ä¿¡å·è¦†ç›–åœ°å›¾</h1>
        <p>å®æ—¶ç›‘æµ‹ç½‘ç»œä¿¡å·è´¨é‡åˆ†å¸ƒæƒ…å†µ</p>
    </div>

    <!-- Excelå¯¼å…¥é¢æ¿ -->
    <div class="import-panel">
        <h3>ğŸ“ Excelæ•°æ®å¯¼å…¥</h3>
        <div class="file-input-wrapper">
            <input type="file" id="excelFile" class="file-input" accept=".xlsx,.xls" />
            <button id="loadBtn" class="btn" onclick="loadExcelData()">åŠ è½½æ•°æ®</button>
            <button id="useDefaultBtn" class="btn" onclick="useDefaultData()">ä½¿ç”¨ç¤ºä¾‹æ•°æ®</button>
        </div>
        <div id="statusMessage"></div>
        <p><strong>Excelæ–‡ä»¶æ ¼å¼è¦æ±‚ï¼š</strong>åŒ…å«åˆ—ï¼šä½ç½®æè¿°ã€è¯¦ç»†åœ°å€ã€ç½‘ç»œç±»å‹ã€ä¿¡å·å¼ºåº¦ã€ä¸ŠæŠ¥æ—¶é—´ã€ä¸ŠæŠ¥äººã€å¤‡æ³¨</p>
    </div>

    <!-- ä¿¡æ¯é¢æ¿ -->
    <div class="info-panel">
        <h3>ğŸ“Š ç›‘æµ‹ç‚¹æ¦‚å†µ</h3>
        <p id="dataInfo">è¯·å¯¼å…¥Excelæ–‡ä»¶æˆ–ä½¿ç”¨ç¤ºä¾‹æ•°æ®</p>
    </div>

    <!-- åœ°å›¾å®¹å™¨ -->
    <div id="map"></div>

    <!-- å›¾ä¾‹è¯´æ˜ -->
    <div class="legend">
        <h4>ğŸ“¶ ä¿¡å·å¼ºåº¦å›¾ä¾‹</h4>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 18px; height: 18px;"></div>
            <span>ä¸¥é‡ç›²åŒº (1-2åˆ†) - çº¢è‰²å¤§æ ‡è®°ï¼Œéœ€è¦ä¼˜å…ˆå¤„ç†</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot red" style="width: 12px; height: 12px;"></div>
            <span>ä¿¡å·è¾ƒå·® (3-4åˆ†) - çº¢è‰²å°æ ‡è®°ï¼Œä¿¡å·ä¸ç¨³å®š</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 12px; height: 12px;"></div>
            <span>ä¿¡å·ä¸€èˆ¬ (5-6åˆ†) - è“è‰²å°æ ‡è®°ï¼Œä¿¡å·å¯ç”¨</span>
        </div>
        <div class="legend-item">
            <div class="legend-dot blue" style="width: 18px; height: 18px;"></div>
            <span>ä¿¡å·è‰¯å¥½ (7-10åˆ†) - è“è‰²å¤§æ ‡è®°ï¼Œä¿¡å·ç¨³å®š</span>
        </div>
    </div>

    <!-- æ§åˆ¶é¢æ¿ -->
    <div class="control-panel">
        <h3>ğŸ“‹ æ§åˆ¶é¢æ¿</h3>
        <div class="control-group">
            <label>çƒ­åŠ›å›¾æ˜¾ç¤º</label>
            <label class="switch">
                <input type="checkbox" id="heatmapSwitch">
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>æ ‡è®°ç‚¹æ˜¾ç¤º</label>
            <label class="switch">
                <input type="checkbox" id="markersSwitch" checked>
                <span class="slider"></span>
            </label>
        </div>
        <div class="control-group">
            <label>ä¿¡å·å¼ºåº¦èŒƒå›´ (æ˜¾ç¤ºâ‰¤è¯¥å€¼çš„ç›‘æµ‹ç‚¹)</label>
            <div class="intensity-control">
                <input type="range" id="intensitySlider" min="1" max="10" value="10">
                <span id="intensityValue">10</span>
            </div>
        </div>
        <div class="control-group">
            <button id="smartAnalysisBtn" class="btn" onclick="runSmartAnalysis()">ğŸ§  æ™ºèƒ½åˆ†æ</button>
            <button id="predictCoverageBtn" class="btn" onclick="predictSignalCoverage()">ğŸ”® ä¿¡å·é¢„æµ‹</button>
        </div>
        <div id="analysisResults" class="analysis-panel" style="display: none;">
            <h4>ğŸ“ˆ æ™ºèƒ½åˆ†æç»“æœ</h4>
            <div id="analysisContent"></div>
        </div>
    </div>

    <!-- å¼•å…¥XLSXè§£æåº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- é«˜å¾·åœ°å›¾API -->
    <script src="https://webapi.amap.com/maps?v=2.0&key=d9f68330ebc73e4856581f67deac33a5&plugin=AMap.HeatMap"></script>
    
    <script>
        /**
         * ===========================================
         * ä¿¡å·è¦†ç›–åœ°å›¾å¯è§†åŒ–ç³»ç»Ÿ
         * Signal Coverage Mapper Visualization System
         * 
         * @description åŸºäºé«˜å¾·åœ°å›¾çš„ç½‘ç»œä¿¡å·è´¨é‡å¯è§†åŒ–å·¥å…·
         * @author Signal Coverage Mapper Team
         * @version 1.0.0
         * @license MIT
         * ===========================================
         */

        // =====================================
        // å…¨å±€å˜é‡å®šä¹‰
        // =====================================
        let map = null;                    // é«˜å¾·åœ°å›¾å®ä¾‹
        let markers = [];                  // æ ‡è®°ç‚¹æ•°ç»„
        let currentData = [];              // å½“å‰æ˜¾ç¤ºçš„æ•°æ®
        let heatmapLayer = null;           // çƒ­åŠ›å›¾å›¾å±‚

        /**
         * ç”Ÿæˆéšæœºçš„å—é€šå¸‚ä¿¡å·ç›‘æµ‹æ•°æ®
         */
        function generateRandomData(count = 1000) {
            const data = [];
            
            // å—é€šå¸‚åŠå‘¨è¾¹æ›´å¤§åŒºåŸŸèŒƒå›´ (ç»çº¬åº¦è¾¹ç•Œ)
            const bounds = {
                minLng: 120.400,  // è¥¿è¾¹ç•Œ - æ‰©å±•åˆ°æµ·å®‰
                maxLng: 121.700,  // ä¸œè¾¹ç•Œ - æ‰©å±•åˆ°å¯ä¸œ
                minLat: 31.700,   // å—è¾¹ç•Œ - æ‰©å±•åˆ°æµ·é—¨å—éƒ¨
                maxLat: 32.600    // åŒ—è¾¹ç•Œ - æ‰©å±•åˆ°å¦‚ä¸œåŒ—éƒ¨
            };
            
            // å—é€šå¸‚å„åŒºå¿å’Œä¸»è¦åœ°æ ‡
            const locations = [
                "å´‡å·åŒº", "æ¸¯é—¸åŒº", "é€šå·åŒº", "æµ·é—¨åŒº", "å¯ä¸œå¸‚", "å¦‚ä¸œå¿", "æµ·å®‰å¸‚",
                "å—é€šå¸‚ä¸­å¿ƒ", "å—é€šç«è½¦ç«™", "å—é€šæ±½è½¦ç«™", "å—é€šå¤§å­¦", "å—é€šåŒ»é™¢",
                "æµ·é—¨å·¥ä¸šå›­", "å¯ä¸œæ¸¯å£", "å¦‚ä¸œé£ç”µåœº", "æµ·å®‰å¼€å‘åŒº", "é€šå·æ¹¾",
                "ç‹¼å±±æ™¯åŒº", "æ¿ æ²³å…¬å›­", "æ£®æ—é‡ç”ŸåŠ¨ç‰©å›­", "å—é€šåšç‰©è‹‘",
                "å•†åœº", "ä½å®…åŒº", "å­¦æ ¡", "åŒ»é™¢", "é“¶è¡Œ", "æ”¿åºœå¤§æ¥¼", "ç¤¾åŒºæœåŠ¡ä¸­å¿ƒ",
                "ä¹¡é•‡", "å†œæ‘", "é«˜é€Ÿå…¬è·¯", "å›½é“", "å¿é“", "ä¹¡é“", "æ¸”æ¸¯", "ç å¤´"
            ];
            
            const networks = ["5G", "4G", "3G"];
            const reporters = ["å¼ ä¸‰", "æå››", "ç‹äº”", "èµµå…­", "é™ˆä¸ƒ", "åˆ˜å…«", "åŒ¿åç”¨æˆ·"];
            
            // é‡ç‚¹ç›‘æµ‹åŒºåŸŸä¸­å¿ƒç‚¹ï¼ˆæŸäº›åŒºåŸŸç›‘æµ‹ç‚¹ä¼šæ›´å¯†é›†ï¼‰
            const hotspots = [
                [120.863, 32.008],  // å—é€šå¸‚ä¸­å¿ƒ
                [121.177, 31.890],  // æµ·é—¨åŒº
                [121.657, 31.810],  // å¯ä¸œå¸‚
                [120.737, 32.481],  // å¦‚ä¸œå¿
                [120.462, 32.546],  // æµ·å®‰å¸‚
                [121.073, 32.267],  // é€šå·åŒº
                [120.885, 32.066]   // æ¸¯é—¸åŒº
            ];
            
            for (let i = 0; i < count; i++) {
                let lng, lat;
                
                // 30%çš„æ¦‚ç‡åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ç”Ÿæˆï¼Œ70%åœ¨å…¨åŸŸéšæœºç”Ÿæˆ
                if (Math.random() < 0.3 && hotspots.length > 0) {
                    // åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ç”Ÿæˆ
                    const hotspot = hotspots[Math.floor(Math.random() * hotspots.length)];
                    const radius = 0.05; // é‡ç‚¹åŒºåŸŸåŠå¾„çº¦5å…¬é‡Œ
                    lng = hotspot[0] + (Math.random() - 0.5) * radius * 2;
                    lat = hotspot[1] + (Math.random() - 0.5) * radius * 2;
                } else {
                    // åœ¨å…¨åŸŸéšæœºç”Ÿæˆ
                    lng = bounds.minLng + Math.random() * (bounds.maxLng - bounds.minLng);
                    lat = bounds.minLat + Math.random() * (bounds.maxLat - bounds.minLat);
                }
                
                // æ ¹æ®ä½ç½®è°ƒæ•´ä¿¡å·å¼ºåº¦åˆ†å¸ƒ
                let signal;
                const rand = Math.random();
                
                // åˆ¤æ–­æ˜¯å¦åœ¨é‡ç‚¹åŒºåŸŸé™„è¿‘ï¼ˆä¿¡å·ç›¸å¯¹è¾ƒå¥½ï¼‰
                const isNearHotspot = hotspots.some(hotspot => {
                    const distance = Math.sqrt(Math.pow(lng - hotspot[0], 2) + Math.pow(lat - hotspot[1], 2));
                    return distance < 0.08; // 8å…¬é‡Œå·¦å³
                });
                
                if (isNearHotspot) {
                    // åŸå¸‚åŒºåŸŸï¼šä¿¡å·ç›¸å¯¹è¾ƒå¥½
                    if (rand < 0.05) signal = Math.floor(Math.random() * 2) + 1;      // 5% ä¸¥é‡ç›²åŒº
                    else if (rand < 0.15) signal = Math.floor(Math.random() * 2) + 3; // 10% ä¿¡å·è¾ƒå·®  
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 3) + 5; // 35% ä¿¡å·ä¸€èˆ¬
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 50% ä¿¡å·è‰¯å¥½
                } else {
                    // éƒŠåŒº/å†œæ‘ï¼šä¿¡å·ç›¸å¯¹è¾ƒå·®
                    if (rand < 0.20) signal = Math.floor(Math.random() * 2) + 1;      // 20% ä¸¥é‡ç›²åŒº
                    else if (rand < 0.50) signal = Math.floor(Math.random() * 2) + 3; // 30% ä¿¡å·è¾ƒå·®  
                    else if (rand < 0.85) signal = Math.floor(Math.random() * 3) + 5; // 35% ä¿¡å·ä¸€èˆ¬
                    else signal = Math.floor(Math.random() * 3) + 8;                  // 15% ä¿¡å·è‰¯å¥½
                }
                
                // éšæœºç”Ÿæˆå…¶ä»–ä¿¡æ¯
                const location = locations[Math.floor(Math.random() * locations.length)];
                const network = networks[Math.floor(Math.random() * networks.length)];
                const reporter = reporters[Math.floor(Math.random() * reporters.length)];
                
                // éšæœºç”Ÿæˆæ—¶é—´ (æœ€è¿‘30å¤©)
                const date = new Date();
                date.setDate(date.getDate() - Math.floor(Math.random() * 30));
                const timeStr = date.toISOString().slice(0, 16).replace('T', ' ');
                
                data.push({
                    name: `${location}ç›‘æµ‹ç‚¹${i + 1}`,
                    position: [lng, lat],
                    signal: signal,
                    network: network,
                    reporter: reporter,
                    time: timeStr,
                    note: signal <= 2 ? "ä¿¡å·ç›²åŒºéœ€è¦é‡ç‚¹å…³æ³¨" : 
                          signal <= 4 ? "ä¿¡å·è¾ƒå¼±ï¼Œå»ºè®®ä¼˜åŒ–" : 
                          signal <= 7 ? "ä¿¡å·æ­£å¸¸" : "ä¿¡å·è‰¯å¥½"
                });
            }
            
            console.log(`ğŸ² ç”Ÿæˆäº†${count}ä¸ªéšæœºç›‘æµ‹ç‚¹æ•°æ®`);
            return data;
        }

        // =====================================
        // é…ç½®å¸¸é‡å®šä¹‰
        // =====================================
        
        // åœ°å›¾é…ç½®
        const MAP_CONFIG = {
            zoom: 10,                    // ç¼©æ”¾çº§åˆ«
            center: [121.05, 32.15],     // å—é€šå¸‚å‡ ä½•ä¸­å¿ƒ
            viewMode: '2D',              // 2Dè§†å›¾æ¨¡å¼
            maxZoom: 18,                 // æœ€å¤§ç¼©æ”¾çº§åˆ«
            minZoom: 3                   // æœ€å°ç¼©æ”¾çº§åˆ«
        };

        // æ ‡è®°ç‚¹é…ç½®
        const MARKER_CONFIG = {
            maxDisplay: 200,             // æœ€å¤§æ˜¾ç¤ºæ ‡è®°ç‚¹æ•°é‡
            severeSizeMultiplier: 1.5,   // ä¸¥é‡ç›²åŒºå¤§å°å€æ•°
            iconBaseSize: 20             // åŸºç¡€å›¾æ ‡å¤§å°
        };

        // ä¿¡å·å¼ºåº¦é˜ˆå€¼é…ç½®
        const SIGNAL_THRESHOLDS = {
            severe: 2,                   // ä¸¥é‡ç›²åŒºï¼šâ‰¤2åˆ†
            poor: 4,                     // ä¿¡å·è¾ƒå·®ï¼š3-4åˆ†
            normal: 6,                   // ä¿¡å·ä¸€èˆ¬ï¼š5-6åˆ†
            good: 10                     // ä¿¡å·è‰¯å¥½ï¼š7-10åˆ†
        };

        // çƒ­åŠ›å›¾é…ç½®
        const HEATMAP_CONFIG = {
            radius: 60,                  // çƒ­åŠ›å›¾åŠå¾„
            opacity: [0, 0.8],           // é€æ˜åº¦èŒƒå›´
            clustering: {
                distance: 15000,         // èšç±»è·ç¦»ï¼ˆç±³ï¼‰
                minPoints: 3             // æœ€å°èšç±»ç‚¹æ•°
            }
        };

        // é»˜è®¤ç¤ºä¾‹æ•°æ® (1000ä¸ªéšæœºç‚¹)
        const DEFAULT_DATA = generateRandomData(1000);

        // =====================================
        // å·¥å…·å‡½æ•°æ¨¡å—
        // =====================================

        /**
         * æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
         * @description åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºæ“ä½œçŠ¶æ€ä¿¡æ¯ï¼Œæ”¯æŒæˆåŠŸã€é”™è¯¯ã€ä¿¡æ¯ç­‰ç±»å‹
         * @param {string} message - è¦æ˜¾ç¤ºçš„æ¶ˆæ¯å†…å®¹
         * @param {string} type - æ¶ˆæ¯ç±»å‹ï¼šsuccess/error/info/warning
         * @returns {void}
         */
        function showMessage(message, type = 'success') {
            const statusDiv = document.getElementById('statusMessage');
            statusDiv.innerHTML = `<div class="status-message ${type}">${message}</div>`;
            
            // 3ç§’åè‡ªåŠ¨æ¸…é™¤æ¶ˆæ¯
            setTimeout(() => {
                statusDiv.innerHTML = '';
            }, 3000);
        }

        /**
         * æ ¹æ®ä¿¡å·å¼ºåº¦è·å–å›¾æ ‡é…ç½®
         * @description æ ¹æ®ä¿¡å·å¼ºåº¦å€¼è¿”å›å¯¹åº”çš„é¢œè‰²ã€å¤§å°å’Œç±»å‹æè¿°
         * @param {number} signal - ä¿¡å·å¼ºåº¦å€¼ (1-10)
         * @returns {Object} åŒ…å«colorã€sizeã€typeçš„é…ç½®å¯¹è±¡
         * @note åªä½¿ç”¨é«˜å¾·åœ°å›¾æ”¯æŒçš„é¢œè‰²ï¼šr(çº¢), b(è“)ï¼Œé€šè¿‡å¤§å°åŒºåˆ†çº§åˆ«
         */
        function getIconConfig(signal) {
            const baseSize = MARKER_CONFIG.iconBaseSize;
            const largeSize = Math.round(baseSize * MARKER_CONFIG.severeSizeMultiplier);
            
            if (signal <= SIGNAL_THRESHOLDS.severe) {
                return { color: 'r', size: largeSize, type: 'ä¸¥é‡ç›²åŒº' };
            } else if (signal <= SIGNAL_THRESHOLDS.poor) {
                return { color: 'r', size: baseSize, type: 'ä¿¡å·è¾ƒå·®' };
            } else if (signal <= SIGNAL_THRESHOLDS.normal) {
                return { color: 'b', size: baseSize, type: 'ä¿¡å·ä¸€èˆ¬' };
            } else {
                return { color: 'b', size: largeSize, type: 'ä¿¡å·è‰¯å¥½' };
            }
        }

        /**
         * åˆ›å»ºè‡ªå®šä¹‰æ ‡è®°å›¾æ ‡
         */
        function createMarkerIcon(color, size = 25) {
            // ä½¿ç”¨ç¡®å®å¯ç”¨çš„v1.3ä¸»é¢˜å›¾æ ‡
            const iconHeight = Math.round(size * 1.36); // ä¿æŒå®½é«˜æ¯”
            return new AMap.Icon({
                size: new AMap.Size(size, iconHeight),
                image: `https://webapi.amap.com/theme/v1.3/markers/n/mark_${color}.png`,
                imageSize: new AMap.Size(size, iconHeight)
            });
        }

        /**
         * è·å–ä¿¡å·å¼ºåº¦æè¿°
         */
        function getSignalDescription(signal) {
            if (signal <= 2) return 'ä¸¥é‡ç›²åŒº ğŸ”´å¤§';
            if (signal <= 4) return 'ä¿¡å·è¾ƒå·® ğŸ”´å°';
            if (signal <= 6) return 'ä¿¡å·ä¸€èˆ¬ ğŸ”µå°';
            return 'ä¿¡å·è‰¯å¥½ ğŸ”µå¤§';
        }

        // =====================================
        // åœ°å›¾æ“ä½œæ¨¡å—
        // =====================================

        /**
         * åˆå§‹åŒ–åœ°å›¾
         * @description åˆ›å»ºé«˜å¾·åœ°å›¾å®ä¾‹ï¼Œè®¾ç½®åŸºæœ¬é…ç½®å’Œäº‹ä»¶ç›‘å¬
         * @returns {void}
         */
        function initMap() {
            console.log('å¼€å§‹åˆå§‹åŒ–åœ°å›¾...');

            // æ£€æŸ¥é«˜å¾·åœ°å›¾APIæ˜¯å¦åŠ è½½æˆåŠŸ
            if (typeof AMap === 'undefined') {
                showMessage('âŒ é«˜å¾·åœ°å›¾APIåŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥ï¼', 'error');
                return;
            }

            try {
                // åˆ›å»ºåœ°å›¾å®ä¾‹
                map = new AMap.Map('map', MAP_CONFIG);
                console.log('âœ… åœ°å›¾åˆ›å»ºæˆåŠŸ');

                // åœ°å›¾åŠ è½½å®Œæˆäº‹ä»¶
                map.on('complete', function() {
                    console.log('âœ… åœ°å›¾åŠ è½½å®Œæˆ');
                    showMessage('âœ… åœ°å›¾åˆå§‹åŒ–æˆåŠŸï¼Œè¯·å¯¼å…¥æ•°æ®æˆ–ä½¿ç”¨ç¤ºä¾‹æ•°æ®');
                    
                    // åˆå§‹åŒ–æ§åˆ¶é¢æ¿äº‹ä»¶
                    initControls();
                });

            } catch (error) {
                console.error('âŒ åœ°å›¾åˆå§‹åŒ–å¤±è´¥:', error);
                showMessage(`âŒ åœ°å›¾åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
            }
        }

        /**
         * æ¸…é™¤åœ°å›¾ä¸Šçš„æ‰€æœ‰æ ‡è®°
         */
        function clearMarkers() {
            if (markers.length > 0) {
                map.remove(markers);
                markers = [];
            }
        }

        /**
         * æ·»åŠ ä¿¡å·ç›‘æµ‹ç‚¹æ ‡è®°
         */
        function addSignalMarkers(data) {
            clearMarkers();
            
            // å¦‚æœæ•°æ®é‡å¤ªå¤§ï¼Œè¿›è¡Œé‡‡æ ·æ˜¾ç¤ºä»¥æé«˜æ€§èƒ½
            let displayData = data;
            const maxMarkers = MARKER_CONFIG.maxDisplay;
            
            if (data.length > maxMarkers) {
                console.log(`æ•°æ®é‡è¿‡å¤§(${data.length}ä¸ªç‚¹)ï¼Œé‡‡æ ·æ˜¾ç¤º${maxMarkers}ä¸ªä»£è¡¨æ€§æ ‡è®°ç‚¹`);
                
                // æŒ‰ä¿¡å·å¼ºåº¦åˆ†å±‚é‡‡æ ·ï¼Œç¡®ä¿å„ç§ä¿¡å·å¼ºåº¦éƒ½æœ‰ä»£è¡¨
                const severeBlinds = data.filter(p => p.signal <= 2);
                const poor = data.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = data.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = data.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                displayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
                
                showMessage(`ğŸ“ é‡‡æ ·æ˜¾ç¤º${displayData.length}ä¸ªä»£è¡¨æ€§ç›‘æµ‹ç‚¹ï¼Œå®Œæ•´æ•°æ®è¯·æŸ¥çœ‹çƒ­åŠ›å›¾`, 'info');
            }
            
            displayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                // åˆ›å»ºæ ‡è®°ç‚¹
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - ä¿¡å·å¼ºåº¦: ${point.signal}/10 (${iconConfig.type})`,
                    icon: icon
                });

                // æ·»åŠ åˆ°åœ°å›¾å’Œæ ‡è®°æ•°ç»„
                map.add(marker);
                markers.push(marker);
            });

            console.log(`âœ… å·²æ·»åŠ ${displayData.length}ä¸ªæ ‡è®°ç‚¹ï¼ˆæ€»æ•°æ®${data.length}ä¸ªï¼‰`);

            // æ›´æ–°ä¿¡æ¯é¢æ¿ï¼ˆä½¿ç”¨å®Œæ•´æ•°æ®ç»Ÿè®¡ï¼‰
            updateInfoPanel(data);
            
            // æ›´æ–°çƒ­åŠ›å›¾
            updateHeatmap();
        }

        /**
         * æ•°ç»„é‡‡æ ·å‡½æ•°
         */
        function sampleArray(array, sampleSize) {
            if (array.length <= sampleSize) return array;
            
            const step = array.length / sampleSize;
            const sampled = [];
            
            for (let i = 0; i < sampleSize; i++) {
                const index = Math.floor(i * step);
                if (index < array.length) {
                    sampled.push(array[index]);
                }
            }
            
            return sampled;
        }

        /**
         * æ›´æ–°ä¿¡æ¯é¢æ¿
         */
        function updateInfoPanel(data) {
            const totalPoints = data.length;
            const severeCount = data.filter(p => p.signal <= 2).length;
            const avgSignal = (data.reduce((sum, p) => sum + p.signal, 0) / totalPoints).toFixed(1);
            
            document.getElementById('dataInfo').innerHTML = `
                å½“å‰æ˜¾ç¤º <strong>${totalPoints}</strong> ä¸ªä¿¡å·ç›‘æµ‹ç‚¹ï¼Œ
                å…¶ä¸­ä¸¥é‡ç›²åŒº <strong>${severeCount}</strong> ä¸ªï¼Œ
                å¹³å‡ä¿¡å·å¼ºåº¦ <strong>${avgSignal}/10</strong>
            `;
        }

        /**
         * ä½¿ç”¨é»˜è®¤ç¤ºä¾‹æ•°æ®
         */
        function useDefaultData() {
            if (!map) {
                showMessage('âŒ è¯·å…ˆç­‰å¾…åœ°å›¾åŠ è½½å®Œæˆ', 'error');
                return;
            }

            currentData = DEFAULT_DATA;
            addSignalMarkers(currentData);
            showMessage(`âœ… å·²åŠ è½½ç¤ºä¾‹æ•°æ®ï¼Œæ˜¾ç¤º${currentData.length}ä¸ªç›‘æµ‹ç‚¹`);
        }

        /**
         * è§£æExcelæ–‡ä»¶
         */
        function parseExcelFile(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = new Uint8Array(e.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                        const jsonData = XLSX.utils.sheet_to_json(firstSheet);
                        resolve(jsonData);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('æ–‡ä»¶è¯»å–å¤±è´¥'));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * å¤„ç†Excelæ•°æ®å¹¶è½¬æ¢ä¸ºåœ°å›¾æ ¼å¼
         */
        function processExcelData(excelData) {
            const processedData = [];
            
            excelData.forEach((row, index) => {
                // æ£€æŸ¥å¿…è¦å­—æ®µ
                if (!row['ä½ç½®æè¿°'] || !row['ä¿¡å·å¼ºåº¦']) {
                    console.warn(`è·³è¿‡ç¬¬${index + 1}è¡Œï¼šç¼ºå°‘å¿…è¦å­—æ®µ`);
                    return;
                }

                // è¿™é‡Œæš‚æ—¶ä½¿ç”¨ç¤ºä¾‹åæ ‡ï¼Œå®é™…åº”è¯¥è°ƒç”¨åœ°ç†ç¼–ç API
                // ä¸ºç®€åŒ–æ¼”ç¤ºï¼Œæˆ‘ä»¬ä½¿ç”¨å—é€šå‘¨è¾¹çš„éšæœºåæ ‡
                const basePosition = [120.863, 32.008];
                const randomOffset = () => (Math.random() - 0.5) * 0.1; // Â±0.05åº¦éšæœºåç§»
                
                const processed = {
                    name: row['ä½ç½®æè¿°'],
                    position: [
                        basePosition[0] + randomOffset(),
                        basePosition[1] + randomOffset()
                    ],
                    signal: parseInt(row['ä¿¡å·å¼ºåº¦']) || 5,
                    network: row['ç½‘ç»œç±»å‹'] || 'æœªçŸ¥',
                    reporter: row['ä¸ŠæŠ¥äºº'] || 'åŒ¿å',
                    time: row['ä¸ŠæŠ¥æ—¶é—´'] || 'æœªçŸ¥',
                    note: row['å¤‡æ³¨'] || 'æ— '
                };

                processedData.push(processed);
            });

            return processedData;
        }

        /**
         * åŠ è½½Excelæ•°æ®
         */
        async function loadExcelData() {
            const fileInput = document.getElementById('excelFile');
            const file = fileInput.files[0];

            if (!file) {
                showMessage('âŒ è¯·å…ˆé€‰æ‹©Excelæ–‡ä»¶', 'error');
                return;
            }

            if (!map) {
                showMessage('âŒ è¯·å…ˆç­‰å¾…åœ°å›¾åŠ è½½å®Œæˆ', 'error');
                return;
            }

            try {
                showMessage('ğŸ“Š æ­£åœ¨è§£æExcelæ–‡ä»¶...', 'info');
                
                // è§£æExcelæ–‡ä»¶
                const excelData = await parseExcelFile(file);
                console.log('Excelæ•°æ®:', excelData);

                // å¤„ç†æ•°æ®
                const processedData = processExcelData(excelData);
                
                if (processedData.length === 0) {
                    showMessage('âŒ æœªæ‰¾åˆ°æœ‰æ•ˆçš„æ•°æ®è¡Œ', 'error');
                    return;
                }

                // æ›´æ–°å½“å‰æ•°æ®å¹¶æ˜¾ç¤ºåœ¨åœ°å›¾ä¸Š
                currentData = processedData;
                addSignalMarkers(currentData);
                
                showMessage(`âœ… æˆåŠŸå¯¼å…¥ ${processedData.length} æ¡æ•°æ®è®°å½•`);

            } catch (error) {
                console.error('Excelå¤„ç†é”™è¯¯:', error);
                showMessage(`âŒ Excelæ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`, 'error');
            }
        }

        /**
         * åˆå§‹åŒ–æ§åˆ¶é¢æ¿
         */
        function initControls() {
            console.log('ğŸ›ï¸ åˆå§‹åŒ–æ§åˆ¶é¢æ¿...');
            
            // çƒ­åŠ›å›¾å¼€å…³
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch) {
                heatmapSwitch.addEventListener('change', function() {
                    console.log('çƒ­åŠ›å›¾å¼€å…³çŠ¶æ€:', this.checked);
                    if (this.checked) {
                        showHeatmap();
                    } else {
                        hideHeatmap();
                    }
                });
                console.log('âœ… çƒ­åŠ›å›¾å¼€å…³äº‹ä»¶ç»‘å®šæˆåŠŸ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°çƒ­åŠ›å›¾å¼€å…³å…ƒç´ ');
            }

            // æ ‡è®°ç‚¹å¼€å…³
            const markersSwitch = document.getElementById('markersSwitch');
            if (markersSwitch) {
                markersSwitch.addEventListener('change', function() {
                    console.log('æ ‡è®°ç‚¹å¼€å…³çŠ¶æ€:', this.checked);
                    if (this.checked) {
                        showMarkers();
                    } else {
                        hideMarkers();
                    }
                });
                console.log('âœ… æ ‡è®°ç‚¹å¼€å…³äº‹ä»¶ç»‘å®šæˆåŠŸ');
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°æ ‡è®°ç‚¹å¼€å…³å…ƒç´ ');
            }

            // å¼ºåº¦æ»‘å—
            const intensitySlider = document.getElementById('intensitySlider');
            const intensityValue = document.getElementById('intensityValue');
            
            if (intensitySlider && intensityValue) {
                // è®¾ç½®åˆå§‹å€¼
                intensityValue.textContent = intensitySlider.value;
                
                intensitySlider.addEventListener('input', function() {
                    intensityValue.textContent = this.value;
                    // åªæœ‰åœ¨æœ‰æ•°æ®æ—¶æ‰è¿›è¡Œç­›é€‰
                    if (currentData && currentData.length > 0) {
                        filterByIntensity(parseInt(this.value));
                    }
                });
                console.log('âœ… å¼ºåº¦æ»‘å—äº‹ä»¶ç»‘å®šæˆåŠŸï¼Œåˆå§‹å€¼:', intensitySlider.value);
            } else {
                console.error('âŒ æ‰¾ä¸åˆ°å¼ºåº¦æ»‘å—å…ƒç´ ');
            }
        }

        /**
         * ç”ŸæˆåŸºäºå®é™…ç›‘æµ‹ç‚¹ä½ç½®çš„çƒ­åŠ›å›¾æ•°æ®
         * ç¡®ä¿çƒ­åŠ›å›¾å’Œæ ‡è®°ç‚¹ä½ç½®å®Œå…¨ä¸€è‡´
         */
        function generateHeatmapData(data) {
            const heatData = [];
            
            console.log('ğŸ—ºï¸ ç”ŸæˆåŸºäºå®é™…ç›‘æµ‹ç‚¹çš„çƒ­åŠ›å›¾...');
            
            // ç›´æ¥ä½¿ç”¨ç›‘æµ‹ç‚¹çš„å®é™…ä½ç½®ï¼Œä¸è¿›è¡Œèšåˆ
            data.forEach((point, index) => {
                // æ ¹æ®ä¿¡å·å¼ºåº¦è®¡ç®—çƒ­åŠ›å€¼ (ä¿¡å·è¶Šå·®ï¼Œçƒ­åŠ›å€¼è¶Šé«˜)
                const baseHeatValue = Math.max(20, (11 - point.signal) * 30);
                
                // ä¸ºæ¯ä¸ªç›‘æµ‹ç‚¹ç”Ÿæˆä¸€ä¸ªå°çš„çƒ­åŠ›åŒºåŸŸ
                const heatPoints = generatePointHeatArea(
                    point.position[0], 
                    point.position[1], 
                    point.signal
                );
                
                heatData.push(...heatPoints);
                
                if (index < 10) { // åªæ‰“å°å‰10ä¸ªç‚¹çš„è¯¦ç»†ä¿¡æ¯
                    console.log(`ğŸ”¥ ç‚¹${index + 1}: ä¿¡å·${point.signal}, ä½ç½®[${point.position[0].toFixed(3)}, ${point.position[1].toFixed(3)}], çƒ­åŠ›å€¼${baseHeatValue}`);
                }
            });
            
            console.log(`ğŸ”¥ åŸºäº${data.length}ä¸ªå®é™…ç›‘æµ‹ç‚¹ç”Ÿæˆ${heatData.length}ä¸ªçƒ­åŠ›ç‚¹`);
            return heatData;
        }
        
        /**
         * è®¡ç®—ä¸¤ç‚¹é—´è·ç¦» (ç”¨äºå…¶ä»–åŠŸèƒ½)
         */
        function calculateDistance(pos1, pos2) {
            return Math.sqrt(
                Math.pow(pos1[0] - pos2[0], 2) + 
                Math.pow(pos1[1] - pos2[1], 2)
            );
        }

        /**
         * è®¡ç®—èšç±»ä¸­å¿ƒç‚¹ (ç”¨äºæ™ºèƒ½åˆ†æ)
         */
        function calculateClusterCenter(cluster) {
            const sumLng = cluster.reduce((sum, point) => sum + point.position[0], 0);
            const sumLat = cluster.reduce((sum, point) => sum + point.position[1], 0);
            return [sumLng / cluster.length, sumLat / cluster.length];
        }
        
        /**
         * ä¸ºå•ä¸ªç›‘æµ‹ç‚¹ç”Ÿæˆçƒ­åŠ›åŒºåŸŸ
         * ç¡®ä¿çƒ­åŠ›å›¾ä½ç½®ä¸æ ‡è®°ç‚¹ä½ç½®å®Œå…¨ä¸€è‡´
         */
        function generatePointHeatArea(centerLng, centerLat, signal) {
            const points = [];
            
            // æ ¹æ®ä¿¡å·å¼ºåº¦ç¡®å®šçƒ­åŠ›åŒºåŸŸå‚æ•°
            const baseRadius = 0.008; // å›ºå®šåŸºç¡€åŠå¾„çº¦800ç±³
            const heatRadius = baseRadius * (1 + (10 - signal) * 0.15); // ä¿¡å·è¶Šå·®ï¼Œå½±å“èŒƒå›´ç¨å¤§
            
            // ä¿¡å·å¼ºåº¦è½¬æ¢ä¸ºçƒ­åŠ›å€¼ (ä¿¡å·è¶Šå·®ï¼Œçƒ­åŠ›å€¼è¶Šé«˜ï¼Œåœ¨çƒ­åŠ›å›¾ä¸­è¶Šçº¢)
            const baseHeatValue = Math.max(15, (11 - signal) * 20);
            
            // ä¸­å¿ƒç‚¹ - ä½¿ç”¨å®é™…ç›‘æµ‹ç‚¹ä½ç½®
            points.push({
                lng: centerLng,
                lat: centerLat,
                count: baseHeatValue
            });
            
            // ç”Ÿæˆå›´ç»•ç›‘æµ‹ç‚¹çš„å°çƒ­åŠ›åŒºåŸŸ
            const layers = 3; // å‡å°‘å±‚æ•°ï¼Œä¿æŒçƒ­åŠ›å›¾ç´§å‡‘
            const pointsPerLayer = 6; // æ¯å±‚6ä¸ªç‚¹
            
            for (let layer = 1; layer <= layers; layer++) {
                const layerRadius = (heatRadius * layer) / layers;
                const layerHeatValue = baseHeatValue * Math.pow(0.6, layer);
                
                for (let i = 0; i < pointsPerLayer; i++) {
                    const angle = (i * 2 * Math.PI) / pointsPerLayer;
                    
                    // è½»å¾®çš„éšæœºåç§»ï¼Œä¿æŒè‡ªç„¶æ„Ÿ
                    const radiusVariation = 0.7 + Math.random() * 0.6; // 0.7-1.3çš„å˜åŒ–
                    const actualRadius = layerRadius * radiusVariation;
                    
                    const lng = centerLng + actualRadius * Math.cos(angle);
                    const lat = centerLat + actualRadius * Math.sin(angle);
                    
                    points.push({
                        lng: lng,
                        lat: lat,
                        count: Math.max(5, layerHeatValue)
                    });
                }
            }
            
            return points;
        }

        /**
         * æ˜¾ç¤ºçƒ­åŠ›å›¾
         */
        function showHeatmap() {
            console.log('ğŸ”¥ å¼€å§‹æ˜¾ç¤ºçƒ­åŠ›å›¾...');
            
            if (!currentData || currentData.length === 0) {
                showMessage('âŒ è¯·å…ˆå¯¼å…¥æ•°æ®', 'error');
                document.getElementById('heatmapSwitch').checked = false;
                return;
            }

            if (heatmapLayer) {
                console.log('æ¸…é™¤ç°æœ‰çƒ­åŠ›å›¾...');
                hideHeatmap();
            }

            try {
                // æ£€æŸ¥AMap.HeatMapæ˜¯å¦å¯ç”¨
                if (typeof AMap === 'undefined' || !AMap.HeatMap) {
                    throw new Error('é«˜å¾·åœ°å›¾çƒ­åŠ›å›¾æ’ä»¶æœªåŠ è½½');
                }

                const heatData = generateHeatmapData(currentData);
                console.log('çƒ­åŠ›å›¾æ•°æ®:', heatData);
                
                heatmapLayer = new AMap.HeatMap(map, {
                    radius: 25, // è¾ƒå°åŠå¾„é€‚åˆå•ç‚¹ç›‘æµ‹æ•°æ®
                    opacity: [0.3, 0.7], // é€‚ä¸­é€æ˜åº¦ä¿æŒæ ‡è®°ç‚¹å¯è§
                    gradient: {
                        '0.0': '#0066ff',  // ä¿¡å·å¥½ - æ·±è“è‰²
                        '0.2': '#0088ff',  // ä¿¡å·è¾ƒå¥½ - è“è‰²
                        '0.4': '#00ff88',  // ä¿¡å·ä¸€èˆ¬ - ç»¿è‰²
                        '0.6': '#ffff00',  // ä¿¡å·è¾ƒå·® - é»„è‰²  
                        '0.8': '#ff8800',  // ä¿¡å·å·® - æ©™è‰²
                        '1.0': '#ff0000'   // ä¿¡å·ç›²åŒº - çº¢è‰²
                    },
                    blur: 0.8, // é€‚åº¦æ¨¡ç³Šè®©çƒ­åŠ›å›¾è‡ªç„¶è¿‡æ¸¡
                    max: 200   // è®¾ç½®æœ€å¤§çƒ­åŠ›å€¼é€‚åº”å•ç‚¹æ•°æ®
                });
                
                // è®¡ç®—æ•°æ®ä¸­çš„æœ€å¤§æƒé‡å€¼
                const maxWeight = Math.max(...heatData.map(item => item.count));
                console.log('çƒ­åŠ›å›¾æœ€å¤§æƒé‡å€¼:', maxWeight);
                
                heatmapLayer.setDataSet({
                    data: heatData,
                    max: maxWeight || 100 // ä½¿ç”¨å®é™…æœ€å¤§å€¼æˆ–é»˜è®¤100
                });

                console.log('âœ… çƒ­åŠ›å›¾æ˜¾ç¤ºæˆåŠŸ');
                showMessage('ğŸ”¥ çƒ­åŠ›å›¾å·²å¼€å¯ï¼Œä½ç½®ä¸æ ‡è®°ç‚¹å®Œå…¨ä¸€è‡´ï¼Œçº¢è‰²åŒºåŸŸä¸ºä¿¡å·ç›²åŒº');
                
            } catch (error) {
                console.error('âŒ çƒ­åŠ›å›¾æ˜¾ç¤ºå¤±è´¥:', error);
                showMessage(`âŒ çƒ­åŠ›å›¾æ˜¾ç¤ºå¤±è´¥: ${error.message}`, 'error');
                document.getElementById('heatmapSwitch').checked = false;
            }
        }

        /**
         * éšè—çƒ­åŠ›å›¾
         */
        function hideHeatmap() {
            console.log('ğŸŒ«ï¸ éšè—çƒ­åŠ›å›¾...');
            if (heatmapLayer) {
                try {
                    heatmapLayer.hide();
                    heatmapLayer.setMap(null);
                    heatmapLayer = null;
                    console.log('âœ… çƒ­åŠ›å›¾å·²éšè—');
                    showMessage('âœ… çƒ­åŠ›å›¾å·²å…³é—­');
                } catch (error) {
                    console.error('éšè—çƒ­åŠ›å›¾å¤±è´¥:', error);
                }
            } else {
                console.log('çƒ­åŠ›å›¾ä¸å­˜åœ¨ï¼Œæ— éœ€éšè—');
            }
        }

        /**
         * æ˜¾ç¤ºæ ‡è®°ç‚¹
         */
        function showMarkers() {
            console.log('ğŸ“ æ˜¾ç¤ºæ ‡è®°ç‚¹...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.show();
                });
                console.log('âœ… æ ‡è®°ç‚¹å·²æ˜¾ç¤º');
                showMessage('ğŸ“ æ ‡è®°ç‚¹å·²æ˜¾ç¤º');
            }
        }

        /**
         * éšè—æ ‡è®°ç‚¹
         */
        function hideMarkers() {
            console.log('ğŸ“ éšè—æ ‡è®°ç‚¹...');
            if (markers.length > 0) {
                markers.forEach(marker => {
                    marker.hide();
                });
                console.log('âœ… æ ‡è®°ç‚¹å·²éšè—');
                showMessage('ğŸ“ æ ‡è®°ç‚¹å·²éšè—');
            }
        }

        /**
         * æ ¹æ®ä¿¡å·å¼ºåº¦ç­›é€‰æ˜¾ç¤º
         */
        function filterByIntensity(maxIntensity) {
            if (!currentData || currentData.length === 0) return;
            
            // ç­›é€‰æ•°æ®
            const filteredData = currentData.filter(point => point.signal <= maxIntensity);
            
            // æ¸…é™¤ç°æœ‰æ ‡è®°
            clearMarkers();
            
            // é‡æ–°æ·»åŠ ç¬¦åˆæ¡ä»¶çš„æ ‡è®° (ä½¿ç”¨ç­›é€‰åçš„æ•°æ®ï¼Œä½†ä¸æ”¹å˜currentData)
            const displayData = filteredData;
            
            // é‡‡æ ·æ˜¾ç¤ºé€»è¾‘ (ä»addSignalMarkerså‡½æ•°å¤åˆ¶è¿‡æ¥)
            let finalDisplayData = displayData;
            const MAX_MARKERS = 200;
            
            if (displayData.length > MAX_MARKERS) {
                const severeBlinds = displayData.filter(p => p.signal <= 2);
                const poor = displayData.filter(p => p.signal >= 3 && p.signal <= 4);
                const normal = displayData.filter(p => p.signal >= 5 && p.signal <= 6);
                const good = displayData.filter(p => p.signal >= 7);
                
                const sampleSize = Math.floor(MAX_MARKERS / 4);
                finalDisplayData = [
                    ...sampleArray(severeBlinds, sampleSize),
                    ...sampleArray(poor, sampleSize),
                    ...sampleArray(normal, sampleSize),
                    ...sampleArray(good, sampleSize)
                ];
            }
            
            // æ·»åŠ æ ‡è®°
            finalDisplayData.forEach((point, index) => {
                const iconConfig = getIconConfig(point.signal);
                const icon = createMarkerIcon(iconConfig.color, iconConfig.size);
                
                const marker = new AMap.Marker({
                    position: point.position,
                    title: `${point.name} - ä¿¡å·å¼ºåº¦: ${point.signal}/10 (${getSignalDescription(point.signal)})`,
                    icon: icon
                });

                map.add(marker);
                markers.push(marker);
            });
            
            // æ›´æ–°ä¿¡æ¯é¢æ¿
            updateInfoPanel(filteredData);
            
            // æ›´æ–°çƒ­åŠ›å›¾ (å¦‚æœå¼€å¯äº†çƒ­åŠ›å›¾)
            if (heatmapLayer) {
                // ç›´æ¥ç”¨ç­›é€‰åçš„æ•°æ®æ›´æ–°çƒ­åŠ›å›¾
                const heatData = generateHeatmapData(filteredData);
                heatmapLayer.setDataSet({
                    data: heatData,
                    max: Math.max(...heatData.map(item => item.count)) || 100
                });
            }
            
            showMessage(`ğŸ” æ˜¾ç¤ºä¿¡å·å¼ºåº¦ â‰¤ ${maxIntensity} çš„ç›‘æµ‹ç‚¹ (${filteredData.length} ä¸ª)`);
        }

        /**
         * æ›´æ–°çƒ­åŠ›å›¾ (æ•°æ®å˜åŒ–æ—¶è°ƒç”¨)
         */
        function updateHeatmap() {
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            if (heatmapSwitch && heatmapSwitch.checked) {
                hideHeatmap();
                setTimeout(showHeatmap, 100);
            }
        }

        /**
         * æµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½
         */
        function testHeatmap() {
            console.log('ğŸ§ª æµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½...');
            console.log('AMapå¯¹è±¡:', typeof AMap);
            console.log('AMap.HeatMapå¯¹è±¡:', typeof AMap.HeatMap);
            console.log('åœ°å›¾å¯¹è±¡:', map);
            console.log('å½“å‰æ•°æ®:', currentData);
            console.log('çƒ­åŠ›å›¾å±‚:', heatmapLayer);
            
            const heatmapSwitch = document.getElementById('heatmapSwitch');
            console.log('çƒ­åŠ›å›¾å¼€å…³å…ƒç´ :', heatmapSwitch);
            console.log('å¼€å…³çŠ¶æ€:', heatmapSwitch ? heatmapSwitch.checked : 'å…ƒç´ ä¸å­˜åœ¨');
            
            // æ‰‹åŠ¨æµ‹è¯•çƒ­åŠ›å›¾å¼€å…³
            if (heatmapSwitch) {
                console.log('ç‚¹å‡»å¼€å…³è¿›è¡Œæµ‹è¯•...');
                heatmapSwitch.click();
            }
        }

        /**
         * æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾æ˜¾ç¤ºï¼ˆè°ƒè¯•ç”¨ï¼‰
         */
        function manualShowHeatmap() {
            console.log('ğŸ”¥ æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾æ˜¾ç¤º...');
            if (currentData.length === 0) {
                useDefaultData();
                setTimeout(() => {
                    showHeatmap();
                }, 1000);
            } else {
                showHeatmap();
            }
        }

        /**
         * æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾éšè—ï¼ˆè°ƒè¯•ç”¨ï¼‰
         */
        function manualHideHeatmap() {
            console.log('ğŸŒ«ï¸ æ‰‹åŠ¨è§¦å‘çƒ­åŠ›å›¾éšè—...');
            hideHeatmap();
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–åœ°å›¾
        window.onload = function() {
            console.log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            initMap();
            
            // 5ç§’åæµ‹è¯•çƒ­åŠ›å›¾åŠŸèƒ½ï¼ˆç»™åœ°å›¾æ—¶é—´åŠ è½½ï¼‰
            setTimeout(testHeatmap, 5000);
            
            // æ·»åŠ å…¨å±€è°ƒè¯•å‡½æ•°
            window.debugAnalysis = function() {
                console.log('ğŸ”§ å¼€å§‹è°ƒè¯•æ™ºèƒ½åˆ†æ...');
                console.log('å½“å‰æ•°æ®:', currentData);
                console.log('KMeansClusterç±»:', KMeansCluster);
                console.log('blindSpotDetector:', blindSpotDetector);
                console.log('signalPredictor:', signalPredictor);
                
                if (currentData && currentData.length > 0) {
                    console.log('æ•°æ®æ ·ä¾‹:', currentData[0]);
                    try {
                        const basicStats = calculateBasicStatistics(currentData);
                        console.log('åŸºç¡€ç»Ÿè®¡æµ‹è¯•é€šè¿‡:', basicStats);
                    } catch (e) {
                        console.error('åŸºç¡€ç»Ÿè®¡æµ‹è¯•å¤±è´¥:', e);
                    }
                }
            };
            
            console.log('ğŸ’¡ å¯ä»¥åœ¨æµè§ˆå™¨æ§åˆ¶å°è¾“å…¥ debugAnalysis() è¿›è¡Œè°ƒè¯•');
        };

        // =====================================
        // é«˜çº§ç®—æ³•æ¨¡å— - æå‡æŠ€æœ¯ä»·å€¼
        // =====================================

        /**
         * K-meansèšç±»ç®—æ³•å®ç°
         * @description ä½¿ç”¨K-meansç®—æ³•å¯¹ä¿¡å·ç›‘æµ‹ç‚¹è¿›è¡Œæ™ºèƒ½èšç±»
         * @param {Array} data - ç›‘æµ‹ç‚¹æ•°æ®
         * @param {number} k - èšç±»æ•°é‡
         * @returns {Array} èšç±»ç»“æœ
         */
        class KMeansCluster {
            constructor(k = 8) {
                this.k = k;
                this.maxIterations = 100;
                this.tolerance = 0.001;
            }

            /**
             * æ‰§è¡ŒK-meansèšç±»
             */
            cluster(data) {
                if (data.length < this.k) {
                    return data.map(point => ({ ...point, cluster: 0 }));
                }

                // 1. åˆå§‹åŒ–èšç±»ä¸­å¿ƒ
                let centroids = this.initializeCentroids(data);
                let previousCentroids;
                let iterations = 0;

                do {
                    previousCentroids = centroids.map(c => ({ ...c }));
                    
                    // 2. åˆ†é…æ•°æ®ç‚¹åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
                    const clusters = this.assignPointsToCentroids(data, centroids);
                    
                    // 3. æ›´æ–°èšç±»ä¸­å¿ƒ
                    centroids = this.updateCentroids(clusters);
                    
                    iterations++;
                } while (
                    iterations < this.maxIterations && 
                    !this.hasConverged(centroids, previousCentroids)
                );

                console.log(`ğŸ§® K-meansèšç±»å®Œæˆï¼Œè¿­ä»£${iterations}æ¬¡ï¼Œç”Ÿæˆ${centroids.length}ä¸ªèšç±»ä¸­å¿ƒ`);
                
                return this.assignPointsToCentroids(data, centroids);
            }

            /**
             * éšæœºåˆå§‹åŒ–èšç±»ä¸­å¿ƒ
             */
            initializeCentroids(data) {
                const centroids = [];
                const used = new Set();
                
                for (let i = 0; i < this.k; i++) {
                    let randomIndex;
                    do {
                        randomIndex = Math.floor(Math.random() * data.length);
                    } while (used.has(randomIndex));
                    
                    used.add(randomIndex);
                    centroids.push({
                        lng: data[randomIndex].position[0],
                        lat: data[randomIndex].position[1],
                        signal: data[randomIndex].signal
                    });
                }
                
                return centroids;
            }

            /**
             * å°†æ•°æ®ç‚¹åˆ†é…åˆ°æœ€è¿‘çš„èšç±»ä¸­å¿ƒ
             */
            assignPointsToCentroids(data, centroids) {
                return data.map(point => {
                    let minDistance = Infinity;
                    let closestCentroid = 0;
                    
                    centroids.forEach((centroid, index) => {
                        const distance = this.calculateDistance(
                            point.position, 
                            [centroid.lng, centroid.lat]
                        );
                        
                        if (distance < minDistance) {
                            minDistance = distance;
                            closestCentroid = index;
                        }
                    });
                    
                    return { ...point, cluster: closestCentroid, distance: minDistance };
                });
            }

            /**
             * æ›´æ–°èšç±»ä¸­å¿ƒ
             */
            updateCentroids(clusteredData) {
                const centroids = [];
                
                for (let i = 0; i < this.k; i++) {
                    const clusterPoints = clusteredData.filter(point => point.cluster === i);
                    
                    if (clusterPoints.length === 0) continue;
                    
                    const avgLng = clusterPoints.reduce((sum, p) => sum + p.position[0], 0) / clusterPoints.length;
                    const avgLat = clusterPoints.reduce((sum, p) => sum + p.position[1], 0) / clusterPoints.length;
                    const avgSignal = clusterPoints.reduce((sum, p) => sum + p.signal, 0) / clusterPoints.length;
                    
                    centroids.push({
                        lng: avgLng,
                        lat: avgLat,
                        signal: avgSignal
                    });
                }
                
                return centroids;
            }

            /**
             * æ£€æŸ¥æ˜¯å¦æ”¶æ•›
             */
            hasConverged(current, previous) {
                return current.every((centroid, index) => {
                    if (!previous[index]) return false;
                    
                    const distance = this.calculateDistance(
                        [centroid.lng, centroid.lat],
                        [previous[index].lng, previous[index].lat]
                    );
                    
                    return distance < this.tolerance;
                });
            }

            /**
             * è®¡ç®—ä¸¤ç‚¹é—´æ¬§å‡ é‡Œå¾—è·ç¦»
             */
            calculateDistance(pos1, pos2) {
                return Math.sqrt(
                    Math.pow(pos1[0] - pos2[0], 2) + 
                    Math.pow(pos1[1] - pos2[1], 2)
                );
            }
        }

        /**
         * ä¿¡å·è¦†ç›–é¢„æµ‹ç®—æ³•
         * @description åŸºäºç°æœ‰ç›‘æµ‹ç‚¹ï¼Œä½¿ç”¨æ’å€¼ç®—æ³•é¢„æµ‹æœªç›‘æµ‹åŒºåŸŸçš„ä¿¡å·å¼ºåº¦
         */
        class SignalPredictor {
            constructor() {
                this.influenceRadius = 0.1; // å½±å“åŠå¾„ï¼ˆåº¦ï¼‰
                this.weightPower = 2; // åè·ç¦»æƒé‡å¹‚æ¬¡
            }

            /**
             * ä½¿ç”¨åè·ç¦»æƒé‡æ’å€¼é¢„æµ‹ä¿¡å·å¼ºåº¦
             * @param {Array} knownPoints - å·²çŸ¥ç›‘æµ‹ç‚¹
             * @param {Array} targetPosition - ç›®æ ‡ä½ç½® [lng, lat]
             * @returns {number} é¢„æµ‹çš„ä¿¡å·å¼ºåº¦
             */
            predictSignalStrength(knownPoints, targetPosition) {
                if (knownPoints.length === 0) return 5; // é»˜è®¤å€¼

                let weightedSum = 0;
                let totalWeight = 0;

                for (const point of knownPoints) {
                    const distance = this.calculateDistance(targetPosition, point.position);
                    
                    // å¦‚æœè·ç¦»å¤ªè¿œï¼Œåˆ™ä¸è€ƒè™‘å…¶å½±å“
                    if (distance > this.influenceRadius) continue;
                    
                    // é¿å…é™¤é›¶é”™è¯¯
                    if (distance < 0.0001) return point.signal;
                    
                    const weight = 1 / Math.pow(distance, this.weightPower);
                    weightedSum += weight * point.signal;
                    totalWeight += weight;
                }

                return totalWeight > 0 ? weightedSum / totalWeight : 5;
            }

            /**
             * ç”Ÿæˆä¿¡å·è¦†ç›–é¢„æµ‹ç½‘æ ¼
             * @param {Array} knownPoints - å·²çŸ¥ç›‘æµ‹ç‚¹
             * @param {Object} bounds - åŒºåŸŸè¾¹ç•Œ
             * @param {number} gridSize - ç½‘æ ¼å¯†åº¦
             * @returns {Array} é¢„æµ‹ç½‘æ ¼æ•°æ®
             */
            generatePredictionGrid(knownPoints, bounds, gridSize = 30) {
                const grid = [];
                const lngStep = (bounds.maxLng - bounds.minLng) / gridSize;
                const latStep = (bounds.maxLat - bounds.minLat) / gridSize;

                for (let i = 0; i <= gridSize; i++) {
                    for (let j = 0; j <= gridSize; j++) {
                        const lng = bounds.minLng + i * lngStep;
                        const lat = bounds.minLat + j * latStep;
                        
                        const predictedSignal = this.predictSignalStrength(
                            knownPoints, 
                            [lng, lat]
                        );

                        grid.push({
                            position: [lng, lat],
                            signal: predictedSignal,
                            confidence: this.calculateConfidence(knownPoints, [lng, lat])
                        });
                    }
                }

                console.log(`ğŸ¯ ç”Ÿæˆ${grid.length}ä¸ªé¢„æµ‹ç‚¹çš„ä¿¡å·è¦†ç›–ç½‘æ ¼`);
                return grid;
            }

            /**
             * è®¡ç®—é¢„æµ‹ç½®ä¿¡åº¦
             */
            calculateConfidence(knownPoints, targetPosition) {
                const nearbyPoints = knownPoints.filter(point => {
                    const distance = this.calculateDistance(targetPosition, point.position);
                    return distance <= this.influenceRadius;
                });

                // ç½®ä¿¡åº¦åŸºäºé™„è¿‘ç›‘æµ‹ç‚¹çš„æ•°é‡å’Œè·ç¦»
                const confidence = Math.min(1, nearbyPoints.length / 5);
                return confidence;
            }

            calculateDistance(pos1, pos2) {
                return Math.sqrt(
                    Math.pow(pos1[0] - pos2[0], 2) + 
                    Math.pow(pos1[1] - pos2[1], 2)
                );
            }
        }

        /**
         * ç›²åŒºæ£€æµ‹ç®—æ³•
         * @description ä½¿ç”¨å‡¸åŒ…ç®—æ³•å’Œå¯†åº¦åˆ†æè¯†åˆ«ä¿¡å·ç›²åŒº
         */
        class BlindSpotDetector {
            constructor() {
                this.blindSpotThreshold = 3; // ç›²åŒºä¿¡å·å¼ºåº¦é˜ˆå€¼
                this.minDensity = 0.1; // æœ€å°å¯†åº¦é˜ˆå€¼
            }

            /**
             * æ£€æµ‹æ½œåœ¨çš„ä¿¡å·ç›²åŒº
             * @param {Array} data - ç›‘æµ‹ç‚¹æ•°æ®
             * @returns {Array} ç›²åŒºåŒºåŸŸ
             */
            detectBlindSpots(data) {
                // 1. ç­›é€‰å‡ºä¿¡å·è¾ƒå·®çš„ç‚¹
                const weakSignalPoints = data.filter(point => 
                    point.signal <= this.blindSpotThreshold
                );

                if (weakSignalPoints.length < 3) {
                    return [];
                }

                // 2. å¯¹å¼±ä¿¡å·ç‚¹è¿›è¡Œèšç±»
                const kmeans = new KMeansCluster(Math.min(5, Math.floor(weakSignalPoints.length / 3)));
                const clusteredPoints = kmeans.cluster(weakSignalPoints);

                // 3. ä¸ºæ¯ä¸ªèšç±»ç”Ÿæˆç›²åŒºè¾¹ç•Œ
                const blindSpots = [];
                const clusterMap = new Map();

                clusteredPoints.forEach(point => {
                    if (!clusterMap.has(point.cluster)) {
                        clusterMap.set(point.cluster, []);
                    }
                    clusterMap.get(point.cluster).push(point);
                });

                clusterMap.forEach((points, clusterId) => {
                    if (points.length >= 3) { // è‡³å°‘3ä¸ªç‚¹æ‰èƒ½å½¢æˆåŒºåŸŸ
                        const boundary = this.generateBlindSpotBoundary(points);
                        blindSpots.push({
                            id: clusterId,
                            points: points,
                            boundary: boundary,
                            avgSignal: points.reduce((sum, p) => sum + p.signal, 0) / points.length,
                            area: this.calculateArea(boundary),
                            severity: this.calculateSeverity(points)
                        });
                    }
                });

                console.log(`ğŸ” æ£€æµ‹åˆ°${blindSpots.length}ä¸ªæ½œåœ¨ç›²åŒº`);
                return blindSpots;
            }

            /**
             * ç”Ÿæˆç›²åŒºè¾¹ç•Œï¼ˆç®€åŒ–å‡¸åŒ…ç®—æ³•ï¼‰
             */
            generateBlindSpotBoundary(points) {
                if (points.length < 3) return [];

                // æ‰¾åˆ°æœ€å·¦ä¸‹è§’çš„ç‚¹ä½œä¸ºèµ·ç‚¹
                let start = points.reduce((min, point) => {
                    if (point.position[1] < min.position[1] || 
                        (point.position[1] === min.position[1] && point.position[0] < min.position[0])) {
                        return point;
                    }
                    return min;
                });

                // ä½¿ç”¨Grahamæ‰«æç®—æ³•çš„ç®€åŒ–ç‰ˆæœ¬
                const sortedPoints = points
                    .filter(p => p !== start)
                    .sort((a, b) => {
                        const angleA = Math.atan2(a.position[1] - start.position[1], a.position[0] - start.position[0]);
                        const angleB = Math.atan2(b.position[1] - start.position[1], b.position[0] - start.position[0]);
                        return angleA - angleB;
                    });

                const hull = [start];
                for (const point of sortedPoints) {
                    while (hull.length > 1 && this.crossProduct(hull[hull.length-2], hull[hull.length-1], point) <= 0) {
                        hull.pop();
                    }
                    hull.push(point);
                }

                return hull.map(p => p.position);
            }

            /**
             * è®¡ç®—å‰ç§¯ï¼ˆç”¨äºå‡¸åŒ…ç®—æ³•ï¼‰
             */
            crossProduct(o, a, b) {
                return (a.position[0] - o.position[0]) * (b.position[1] - o.position[1]) - 
                       (a.position[1] - o.position[1]) * (b.position[0] - o.position[0]);
            }

            /**
             * è®¡ç®—åŒºåŸŸé¢ç§¯
             */
            calculateArea(boundary) {
                if (boundary.length < 3) return 0;
                
                let area = 0;
                for (let i = 0; i < boundary.length; i++) {
                    const j = (i + 1) % boundary.length;
                    area += boundary[i][0] * boundary[j][1];
                    area -= boundary[j][0] * boundary[i][1];
                }
                return Math.abs(area) / 2;
            }

            /**
             * è®¡ç®—ç›²åŒºä¸¥é‡ç¨‹åº¦
             */
            calculateSeverity(points) {
                const avgSignal = points.reduce((sum, p) => sum + p.signal, 0) / points.length;
                const density = points.length;
                
                // ç»¼åˆä¿¡å·å¼ºåº¦å’Œå¯†åº¦è®¡ç®—ä¸¥é‡ç¨‹åº¦
                return Math.max(0, Math.min(10, (4 - avgSignal) * density * 0.5));
            }
        }

        // =====================================
        // å®ä¾‹åŒ–é«˜çº§ç®—æ³•ç±»
        // =====================================
        const signalPredictor = new SignalPredictor();
        const blindSpotDetector = new BlindSpotDetector();

        // =====================================
        // æ™ºèƒ½åˆ†æåŠŸèƒ½æ¨¡å—
        // =====================================

        /**
         * æ‰§è¡Œæ™ºèƒ½åˆ†æ
         * @description ç»¼åˆè¿ç”¨å¤šç§ç®—æ³•åˆ†æä¿¡å·è¦†ç›–çŠ¶å†µ
         */
        async function runSmartAnalysis() {
            if (!currentData || currentData.length === 0) {
                showMessage('âŒ è¯·å…ˆå¯¼å…¥æ•°æ®', 'error');
                return;
            }

            showMessage('ğŸ§  æ­£åœ¨è¿›è¡Œæ™ºèƒ½åˆ†æ...', 'info');
            console.log('ğŸ§  å¼€å§‹æ™ºèƒ½åˆ†æï¼Œæ•°æ®ç‚¹æ•°é‡:', currentData.length);
            
            try {
                // 1. åŸºç¡€ç»Ÿè®¡åˆ†æ
                console.log('ğŸ“Š æ‰§è¡ŒåŸºç¡€ç»Ÿè®¡åˆ†æ...');
                const basicStats = calculateBasicStatistics(currentData);
                console.log('åŸºç¡€ç»Ÿè®¡å®Œæˆ:', basicStats);
                
                // 2. èšç±»åˆ†æ
                console.log('ğŸ¯ æ‰§è¡Œèšç±»åˆ†æ...');
                const kmeans = new KMeansCluster(6);
                const clusteredData = kmeans.cluster(currentData);
                const clusterAnalysis = analyzeClusterDistribution(clusteredData);
                console.log('èšç±»åˆ†æå®Œæˆ:', clusterAnalysis);
                
                // 3. ç›²åŒºæ£€æµ‹
                console.log('ğŸ” æ‰§è¡Œç›²åŒºæ£€æµ‹...');
                const blindSpots = blindSpotDetector.detectBlindSpots(currentData);
                console.log('ç›²åŒºæ£€æµ‹å®Œæˆ:', blindSpots);
                
                // 4. ä¿¡å·åˆ†å¸ƒåˆ†æ
                console.log('ğŸ“¡ æ‰§è¡Œä¿¡å·åˆ†å¸ƒåˆ†æ...');
                const distributionAnalysis = analyzeSignalDistribution(currentData);
                console.log('ä¿¡å·åˆ†å¸ƒåˆ†æå®Œæˆ:', distributionAnalysis);
                
                // 5. è¦†ç›–è´¨é‡è¯„ä¼°
                console.log('â­ æ‰§è¡Œè¦†ç›–è´¨é‡è¯„ä¼°...');
                const coverageQuality = assessCoverageQuality(currentData);
                console.log('è¦†ç›–è´¨é‡è¯„ä¼°å®Œæˆ:', coverageQuality);
                
                // 6. ä¼˜åŒ–å»ºè®®
                console.log('ğŸ’¡ ç”Ÿæˆä¼˜åŒ–å»ºè®®...');
                const recommendations = generateRecommendations({
                    basicStats,
                    clusterAnalysis,
                    blindSpots,
                    distributionAnalysis,
                    coverageQuality
                });
                console.log('ä¼˜åŒ–å»ºè®®ç”Ÿæˆå®Œæˆ:', recommendations);

                // æ˜¾ç¤ºåˆ†æç»“æœ
                console.log('ğŸ“‹ æ˜¾ç¤ºåˆ†æç»“æœ...');
                displayAnalysisResults({
                    basicStats,
                    clusterAnalysis,
                    blindSpots,
                    distributionAnalysis,
                    coverageQuality,
                    recommendations
                });

                console.log('âœ… æ™ºèƒ½åˆ†æå…¨éƒ¨å®Œæˆ');
                showMessage('âœ… æ™ºèƒ½åˆ†æå®Œæˆ', 'success');
                
            } catch (error) {
                console.error('âŒ æ™ºèƒ½åˆ†æå¤±è´¥è¯¦ç»†ä¿¡æ¯:', error);
                console.error('é”™è¯¯å †æ ˆ:', error.stack);
                console.error('å½“å‰æ•°æ®çŠ¶æ€:', currentData);
                
                // æ˜¾ç¤ºå…·ä½“é”™è¯¯ä¿¡æ¯
                const errorMsg = error.message || 'æœªçŸ¥é”™è¯¯';
                showMessage(`âŒ æ™ºèƒ½åˆ†æå¤±è´¥: ${errorMsg}`, 'error');
                
                // å°è¯•æ˜¾ç¤ºéƒ¨åˆ†ç»“æœï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                try {
                    const basicStats = calculateBasicStatistics(currentData);
                    if (basicStats) {
                        console.log('éƒ¨åˆ†ç»Ÿè®¡ç»“æœ:', basicStats);
                        showMessage('âš ï¸ éƒ¨åˆ†åˆ†æç»“æœå¯ç”¨ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°', 'warning');
                    }
                } catch (e) {
                    console.error('è¿åŸºç¡€ç»Ÿè®¡éƒ½å¤±è´¥:', e);
                }
            }
        }

        /**
         * è®¡ç®—åŸºç¡€ç»Ÿè®¡ä¿¡æ¯
         */
        function calculateBasicStatistics(data) {
            const signals = data.map(d => d.signal);
            const total = signals.length;
            const sum = signals.reduce((a, b) => a + b, 0);
            const avg = sum / total;
            
            const sortedSignals = [...signals].sort((a, b) => a - b);
            const median = total % 2 === 0 
                ? (sortedSignals[total/2 - 1] + sortedSignals[total/2]) / 2
                : sortedSignals[Math.floor(total/2)];
            
            const variance = signals.reduce((sum, signal) => sum + Math.pow(signal - avg, 2), 0) / total;
            const stdDev = Math.sqrt(variance);
            
            const severeBlinds = data.filter(d => d.signal <= 2).length;
            const poorSignal = data.filter(d => d.signal >= 3 && d.signal <= 4).length;
            const normalSignal = data.filter(d => d.signal >= 5 && d.signal <= 6).length;
            const goodSignal = data.filter(d => d.signal >= 7).length;

            return {
                total,
                average: avg,
                median,
                standardDeviation: stdDev,
                minimum: Math.min(...signals),
                maximum: Math.max(...signals),
                severeBlinds,
                poorSignal,
                normalSignal,
                goodSignal,
                severeBlindRate: (severeBlinds / total * 100),
                goodSignalRate: (goodSignal / total * 100)
            };
        }

        /**
         * åˆ†æèšç±»åˆ†å¸ƒ
         */
        function analyzeClusterDistribution(clusteredData) {
            const clusterMap = new Map();
            
            clusteredData.forEach(point => {
                if (!clusterMap.has(point.cluster)) {
                    clusterMap.set(point.cluster, []);
                }
                clusterMap.get(point.cluster).push(point);
            });

            const clusters = [];
            clusterMap.forEach((points, clusterId) => {
                const avgSignal = points.reduce((sum, p) => sum + p.signal, 0) / points.length;
                const center = calculateClusterCenter(points);
                
                clusters.push({
                    id: clusterId,
                    size: points.length,
                    avgSignal: avgSignal,
                    center: center,
                    quality: avgSignal >= 7 ? 'ä¼˜ç§€' : avgSignal >= 5 ? 'è‰¯å¥½' : avgSignal >= 3 ? 'ä¸€èˆ¬' : 'å·®'
                });
            });

            return {
                clusterCount: clusters.length,
                clusters: clusters,
                avgClusterSize: clusters.reduce((sum, c) => sum + c.size, 0) / clusters.length,
                bestCluster: clusters.reduce((best, current) => 
                    current.avgSignal > best.avgSignal ? current : best
                ),
                worstCluster: clusters.reduce((worst, current) => 
                    current.avgSignal < worst.avgSignal ? current : worst
                )
            };
        }

        /**
         * åˆ†æä¿¡å·åˆ†å¸ƒ
         */
        function analyzeSignalDistribution(data) {
            const networkTypes = {};
            data.forEach(point => {
                if (!networkTypes[point.network]) {
                    networkTypes[point.network] = { count: 0, totalSignal: 0 };
                }
                networkTypes[point.network].count++;
                networkTypes[point.network].totalSignal += point.signal;
            });

            // è®¡ç®—å„ç½‘ç»œç±»å‹çš„å¹³å‡ä¿¡å·å¼ºåº¦
            Object.keys(networkTypes).forEach(type => {
                networkTypes[type].avgSignal = networkTypes[type].totalSignal / networkTypes[type].count;
            });

            // åœ°ç†åˆ†å¸ƒåˆ†æ
            const bounds = {
                minLng: Math.min(...data.map(d => d.position[0])),
                maxLng: Math.max(...data.map(d => d.position[0])),
                minLat: Math.min(...data.map(d => d.position[1])),
                maxLat: Math.max(...data.map(d => d.position[1]))
            };

            const coverage = {
                longitudeSpan: bounds.maxLng - bounds.minLng,
                latitudeSpan: bounds.maxLat - bounds.minLat,
                centerPoint: [(bounds.minLng + bounds.maxLng) / 2, (bounds.minLat + bounds.maxLat) / 2]
            };

            return {
                networkTypes,
                coverage,
                bounds
            };
        }

        /**
         * è¯„ä¼°è¦†ç›–è´¨é‡
         */
        function assessCoverageQuality(data) {
            const basicStats = calculateBasicStatistics(data);
            
            // è®¡ç®—è¦†ç›–è´¨é‡å¾—åˆ† (0-100)
            let qualityScore = 0;
            
            // å¹³å‡ä¿¡å·å¼ºåº¦æƒé‡ 40%
            qualityScore += (basicStats.average / 10) * 40;
            
            // ä¸¥é‡ç›²åŒºç‡æƒé‡ 30% (è¶Šå°‘è¶Šå¥½)
            qualityScore += (1 - basicStats.severeBlindRate / 100) * 30;
            
            // ä¿¡å·ç¨³å®šæ€§æƒé‡ 20% (æ ‡å‡†å·®è¶Šå°è¶Šå¥½ï¼Œæœ€å¤§10åˆ†)
            const stabilityScore = Math.max(0, 10 - basicStats.standardDeviation) / 10;
            qualityScore += stabilityScore * 20;
            
            // å¥½ä¿¡å·æ¯”ä¾‹æƒé‡ 10%
            qualityScore += (basicStats.goodSignalRate / 100) * 10;

            // ç¡®å®šè´¨é‡ç­‰çº§
            let qualityGrade;
            if (qualityScore >= 85) qualityGrade = 'A+ ä¼˜ç§€';
            else if (qualityScore >= 75) qualityGrade = 'A è‰¯å¥½';
            else if (qualityScore >= 65) qualityGrade = 'B+ ä¸­ä¸Š';
            else if (qualityScore >= 55) qualityGrade = 'B ä¸­ç­‰';
            else if (qualityScore >= 45) qualityGrade = 'C+ ä¸­ä¸‹';
            else if (qualityScore >= 35) qualityGrade = 'C è¾ƒå·®';
            else qualityGrade = 'D å·®';

            return {
                score: qualityScore,
                grade: qualityGrade,
                strengths: [],
                weaknesses: []
            };
        }

        /**
         * ç”Ÿæˆä¼˜åŒ–å»ºè®®
         */
        function generateRecommendations(analysisData) {
            const recommendations = [];
            const { basicStats, blindSpots, coverageQuality } = analysisData;

            // åŸºäºç›²åŒºæ•°é‡çš„å»ºè®®
            if (basicStats.severeBlindRate > 20) {
                recommendations.push({
                    type: 'critical',
                    title: 'ä¸¥é‡ç›²åŒºè¿‡å¤š',
                    description: `æ£€æµ‹åˆ°${basicStats.severeBlinds}ä¸ªä¸¥é‡ç›²åŒºï¼ˆ${basicStats.severeBlindRate.toFixed(1)}%ï¼‰ï¼Œå»ºè®®ä¼˜å…ˆéƒ¨ç½²åŸºç«™`,
                    priority: 'high'
                });
            }

            // åŸºäºä¿¡å·è´¨é‡çš„å»ºè®®
            if (basicStats.average < 5) {
                recommendations.push({
                    type: 'warning',
                    title: 'æ•´ä½“ä¿¡å·è´¨é‡åä½',
                    description: 'å¹³å‡ä¿¡å·å¼ºåº¦ä»…ä¸º' + basicStats.average.toFixed(1) + 'åˆ†ï¼Œå»ºè®®å…¨é¢ä¼˜åŒ–ç½‘ç»œè¦†ç›–',
                    priority: 'high'
                });
            }

            // åŸºäºç›²åŒºåˆ†å¸ƒçš„å»ºè®®
            if (blindSpots.length > 0) {
                recommendations.push({
                    type: 'info',
                    title: 'ç›²åŒºèšé›†åˆ†æ',
                    description: `å‘ç°${blindSpots.length}ä¸ªç›²åŒºèšé›†åŒºåŸŸï¼Œå»ºè®®é’ˆå¯¹æ€§éƒ¨ç½²å°åŸºç«™æˆ–ä¸­ç»§è®¾å¤‡`,
                    priority: 'medium'
                });
            }

            // åŸºäºè¦†ç›–è´¨é‡çš„å»ºè®®
            if (coverageQuality.score < 60) {
                recommendations.push({
                    type: 'warning',
                    title: 'ç½‘ç»œè¦†ç›–è´¨é‡éœ€è¦æ”¹å–„',
                    description: `å½“å‰è¦†ç›–è´¨é‡å¾—åˆ†${coverageQuality.score.toFixed(1)}åˆ†ï¼Œç­‰çº§${coverageQuality.grade}`,
                    priority: 'medium'
                });
            }

            return recommendations;
        }

        /**
         * æ˜¾ç¤ºåˆ†æç»“æœ
         */
        function displayAnalysisResults(results) {
            const { basicStats, clusterAnalysis, blindSpots, coverageQuality, recommendations } = results;
            
            const content = `
                <div class="analysis-item">
                    <h5>ğŸ“Š åŸºç¡€ç»Ÿè®¡</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">ç›‘æµ‹ç‚¹æ€»æ•°</span>
                        <span class="metric-value">${basicStats.total}</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">å¹³å‡ä¿¡å·å¼ºåº¦</span>
                        <span class="metric-value">${basicStats.average.toFixed(2)}/10</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">ä¸¥é‡ç›²åŒº</span>
                        <span class="metric-value">${basicStats.severeBlinds} (${basicStats.severeBlindRate.toFixed(1)}%)</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">ä¿¡å·ç¨³å®šæ€§</span>
                        <span class="metric-value">Ïƒ = ${basicStats.standardDeviation.toFixed(2)}</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>ğŸ¯ èšç±»åˆ†æ</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">èšç±»æ•°é‡</span>
                        <span class="metric-value">${clusterAnalysis.clusterCount}</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">å¹³å‡èšç±»å¤§å°</span>
                        <span class="metric-value">${clusterAnalysis.avgClusterSize.toFixed(0)}ä¸ªç‚¹</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">æœ€ä½³èšç±»ä¿¡å·</span>
                        <span class="metric-value">${clusterAnalysis.bestCluster.avgSignal.toFixed(1)}/10</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>ğŸ” ç›²åŒºæ£€æµ‹</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">æ£€æµ‹åˆ°ç›²åŒº</span>
                        <span class="metric-value">${blindSpots.length}ä¸ª</span>
                    </div>
                    ${blindSpots.length > 0 ? `
                    <div class="analysis-metric">
                        <span class="metric-label">æœ€ä¸¥é‡ç›²åŒº</span>
                        <span class="metric-value">ä¸¥é‡åº¦ ${Math.max(...blindSpots.map(b => b.severity)).toFixed(1)}</span>
                    </div>` : ''}
                </div>

                <div class="analysis-item">
                    <h5>â­ è¦†ç›–è´¨é‡è¯„ä¼°</h5>
                    <div class="analysis-metric">
                        <span class="metric-label">è´¨é‡å¾—åˆ†</span>
                        <span class="metric-value">${coverageQuality.score.toFixed(1)}/100</span>
                    </div>
                    <div class="analysis-metric">
                        <span class="metric-label">è´¨é‡ç­‰çº§</span>
                        <span class="metric-value">${coverageQuality.grade}</span>
                    </div>
                </div>

                <div class="analysis-item">
                    <h5>ğŸ’¡ ä¼˜åŒ–å»ºè®®</h5>
                    ${recommendations.map(rec => `
                        <div style="margin: 8px 0; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 6px;">
                            <strong>${rec.title}</strong><br>
                            <small>${rec.description}</small>
                        </div>
                    `).join('')}
                </div>
            `;

            document.getElementById('analysisContent').innerHTML = content;
            document.getElementById('analysisResults').style.display = 'block';
        }

        /**
         * é¢„æµ‹ä¿¡å·è¦†ç›–
         */
        function predictSignalCoverage() {
            if (!currentData || currentData.length === 0) {
                showMessage('âŒ è¯·å…ˆå¯¼å…¥æ•°æ®', 'error');
                return;
            }

            showMessage('ğŸ”® æ­£åœ¨è¿›è¡Œä¿¡å·è¦†ç›–é¢„æµ‹...', 'info');

            try {
                // è®¡ç®—é¢„æµ‹åŒºåŸŸè¾¹ç•Œ
                const bounds = {
                    minLng: Math.min(...currentData.map(d => d.position[0])) - 0.05,
                    maxLng: Math.max(...currentData.map(d => d.position[0])) + 0.05,
                    minLat: Math.min(...currentData.map(d => d.position[1])) - 0.05,
                    maxLat: Math.max(...currentData.map(d => d.position[1])) + 0.05
                };

                // ç”Ÿæˆé¢„æµ‹ç½‘æ ¼
                const predictionGrid = signalPredictor.generatePredictionGrid(currentData, bounds, 25);
                
                // å°†é¢„æµ‹ç»“æœå åŠ åˆ°çƒ­åŠ›å›¾
                updateHeatmapWithPrediction(predictionGrid);
                
                showMessage('âœ… ä¿¡å·è¦†ç›–é¢„æµ‹å®Œæˆï¼Œé¢„æµ‹ç»“æœå·²æ˜¾ç¤ºåœ¨çƒ­åŠ›å›¾ä¸­', 'success');
                
                // è‡ªåŠ¨å¼€å¯çƒ­åŠ›å›¾æ˜¾ç¤º
                document.getElementById('heatmapSwitch').checked = true;
                showHeatmap();
                
            } catch (error) {
                console.error('ä¿¡å·é¢„æµ‹å¤±è´¥:', error);
                showMessage('âŒ ä¿¡å·é¢„æµ‹å¤±è´¥', 'error');
            }
        }

        /**
         * æ›´æ–°çƒ­åŠ›å›¾åŒ…å«é¢„æµ‹æ•°æ®
         */
        function updateHeatmapWithPrediction(predictionGrid) {
            // è¿™é‡Œå¯ä»¥å°†é¢„æµ‹æ•°æ®ä¸å®é™…æ•°æ®ç»“åˆ
            // ä¸ºäº†æ¼”ç¤ºï¼Œæˆ‘ä»¬å°†é¢„æµ‹æ•°æ®æ·»åŠ åˆ°å½“å‰æ•°æ®ä¸­
            const combinedData = [...currentData];
            
            // æ·»åŠ é«˜ç½®ä¿¡åº¦çš„é¢„æµ‹ç‚¹
            predictionGrid.forEach(pred => {
                if (pred.confidence > 0.5) { // åªæ·»åŠ é«˜ç½®ä¿¡åº¦çš„é¢„æµ‹
                    combinedData.push({
                        position: pred.position,
                        signal: pred.signal,
                        isPredicted: true
                    });
                }
            });

            console.log(`ğŸ”® ç»“åˆ${predictionGrid.length}ä¸ªé¢„æµ‹ç‚¹è¿›è¡Œçƒ­åŠ›å›¾æ›´æ–°`);
            
            // é‡æ–°ç”Ÿæˆçƒ­åŠ›å›¾
            const heatData = generateHeatmapData(combinedData);
            
            if (heatmapLayer) {
                heatmapLayer.setDataSet({ data: heatData, max: 200 });
            }
        }
    </script>
</body>
</html> 